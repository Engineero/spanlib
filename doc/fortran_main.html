<html>
<head>
	<title>PcaMssa</title>
	<meta content="">
	<link rel="stylesheet" type="text/css" href="fortran.css">
</head>

<body>

<h1><a name="top"></a>PcaMssa fortran 90 module</h1>

<h2><a name="outl"></a>1. Outline</h2>
<ol>
	<li><a href="#outl">Outline</a></li>
	<li><a href="#intr">Introduction</a></li>
	<li>
		<a href="#f90s">F90 subroutines</a>
		<ul>
			<li><code class="b"><a href="#pca">pca</a></code></li>
			<li><code class="b"><a href="#pcarec">pcarec</a></code></li>
			<li><code class="b"><a href="#mssa">mssa</a></code></li>
			<li><code class="b"><a href="#mssarec">mssarec</a></code></li>
			<li><code class="b"><a href="#phasecomp">phasecomp</a></code></li>
			<li><code class="b"><a href="#diasym">diasym</a></code></li>
		</ul>
	<li><a href="#exam">Example</a></li>
	<li><a href="#refe">References</a></li>
	<li><a href="#cont">Contact</a></li>
</ol>

<h2><a name="intr"></a>2. Introduction<a href="#top" class="top">[Top]</a></h2>


<p>This package provides a F90 module containg a minmal collection of subroutine to perform
<span class="g">Principal Componant Analysis</span> (PCA), 
<span class="g">Multi-channel Singular Spectrum Analysis</span> (MSSA), reconstruction
of components and phase composites.
</p>

<p>
<span class="g">PCA</span> is also know as Empirical Orthogonal Functions (EOFs) decomposition:
it decomposes a space-time signal in pairs of spatial EOFs and temporal PCs
that are the eigen solutions of the covariance (or correlation) matrix of the initial signal.
</p>

<p>
<span class="g">MSSA</span> works in the same way except that EOF are spatio-temporal, and that the diagonalized
matrix is built not only using covariances (or correlations) between spatial points,
but also lag covariances.
Therefore, MSSA is particularly efficient to remove white noise, and extract oscillations and nonlinear
trends, even on short sample.
It uses a window parameter that corresponds to the maximal lag for lag correlations.
Oscillations with a period lower than this window can be typically extracted by MSSA.
</p>

<p>
The package also provides the possibility to <span class="g">reconstruct part of the signal</span>
due to selected modes, for both PCA and MSSA.
Finally, <span class="g">oscillations</span> extracted by MSSA and reconstructed can be reorganized
in <span class="g">phases composites</span>: the oscillations are presented over their averaged cycle,
decomposed in a fixed number of phases
(like one can do for the annual cycle over 12 months for example).

<p>
More information about PCA and MSSA may be found in papers and on the web.
See for example:
<ul>
	<li>MSSA: <a href="#plva94">Plaut and Vautard, 1994</a>.
</ul>
</p>

<p>
The package contains :
<ul>
	<li> an library file: <span class="b"><code>pcamssa.a</code></span></li>
	<li> an include file: <span class="b"><code>pcamssa.mod</code></span></li>
</ul>
</p>

<h2><a name="f90s"></a>3. F90 subroutines<a href="#top" class="top">[Top]</a></h2>
<p>An html version of the source code is available here: <a href="../doc/fortran_code.html"><code class="b">pcamssa.f90</code></a>.</p>
<h3>Principal Component Analysis: <code><a name="pca" class="b">pca</a></code></h3>
<div class="sh3">

<h4>Usage:</h4>
<code><p>call <span class="b">pca</span>(<span class="b">ff</span>, nkeep=<span class="b">nkeep</span>, eof=<span class="b">eof</span>, pc=<span class="b">pc</span>, ev=<span class="b">ev</span>, weights=<span class="b">weights</span>, useteof=<span class="b">useteof</span>)</p></code>

<h4>Description</h4>
<p>
Perform a decomposition of space-time field in a set of
Empirical Orthogonal Functions (EOFs) and Principal components (PCs).
The input data set can be optionally weighted in space.
By default, the analysis computes  "temporal" (T) or classical
spatial (S) EOFs depending on if the space dimension is greater
than the time dimension. This default behavior can be overridden.
</p>

<h4>Necessary arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>ff</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">			Space-time array</td>
	</tr>
</table>

<h4>Optional arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>nkeep</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">		Maximum number of modes to keep in outputs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>eof</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%">		Space-mode array of EOFs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>pc</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%">			Time-mode array of PCs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>ev</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%">			Mode array of eigen values (variances)</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>weights</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">	Space array of weights</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>useteof</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">	To force the use of T or S EOFs [0 = T, 1 = S, -1 = default]</td>
	</tr>
</table>

<h4>Dependencies</h4>
<p>
<span class='b'><code><a href="#diasym">diasym</a></code></span>
</p>

</div>
<br />

<h3>Reconstruction of a set of PCA components: <code><a name="pcarec" class="b">pcarec</a></code></h3>
<div class="sh3">

<h4>Usage:</h4>
<code><p>call <span class="b">pcarec</span>(<span class="b">eof</span>, <span class="b">pc</span>, <span class="b">ffrec</span>, istart=<span class="b">istart</span>, iend=<span class="b">iend</span>)</p></code>

<h4>Description</h4>
<p>
Perform a reconstruction using a set of components previously
computed with a PCA. All the reconstructed components are summed.
A reconstructed component is simply the "product" of an EOF
by its PC. The sum of all reconstructed component is the original field.
</p>

<h4>Necessary arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>eof</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">	Space-mode array of EOFs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>pc</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">		Time-mode array of PCs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>ffrec</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%">	Space-time array of the reconstructed field</td>
	</tr>
</table>

<h4>Optional arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>istart</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">	Index of the first component to use</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>iend</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">	Index of the last component to use</td>
	</tr>
</table>

</div>
<br />

<h3>Multi-channel Singular Spectrum Analysis: <code><a name="mssa" class="b">mssa</a></code></h3>
<div class="sh3">

<h4>Usage:</h4>
<code><p>call <span class="b">mssa</span>(<span class="b">ff</span>, <span class="b">nwindow</span>, <span class="b">nkeep</span>, steof=<span class="b">steof</span>, stpc=<span class="b">stpc</span>, ev=<span class="b">ev</span>)</p></code>

<h4>Description</h4>
<p>
Perform a decomposition of space-time field in a set of
space-time Empirical Orthogonal Functions (EOFs) and 
time Principal components (PCs), according to a window
parameter.
</p>

<h4>Necessary arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>ff</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">			Space-time array</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>nwindow</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">	Window size</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>nkeep</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">		Maximum number of modes to keep in outputs</td>
	</tr>
</table>

<h4>Optional arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>steof</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%">		SpaceXwindow-mode array of EOFs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>stpc</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%">			Time-mode array of PCs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>ev</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%">			Mode array of eigen values (variances)</td>
	</tr>
</table>

<h4>Dependencies</h4>
<p>
<span class='b'><code><a href="#diasym">diasym</a></code></span>
</p>

</div>
<br />

<h3>Reconstruction of a set of MSSA components: <code><a name="mssarec" class="b">mssarec</a></code></h3>
<div class="sh3">

<h4>Usage:</h4>
<code><p>call <span class="b">mssarec</span>(<span class="b">steof</span>, <span class="b">stpc</span>, <span class="b">nwindow</span>, <span class="b">ffrec</span>, istart=<span class="b">istart</span>, iend=<span class="b">iend</span>)</p></code>

<h4>Description</h4>
<p>
Same as for the reconstruction of PCA components, but for MSSA.
</p>

<h4>Necessary arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>steof</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">		SpaceXwindow-mode array of EOFs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>stpc</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">		Time-mode array of PCs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>nwindow</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">	Window size</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>ffrec</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%">		Space-time array of the reconstructed field</td>
	</tr>
</table>

<h4>Optional arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>istart</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">		Index of the first component to use</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>iend</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">		Index of the last component to use</td>
	</tr>
</table>

</div>
<br />

<h3>Phase composites: <code><a name="phasecomp" class="b">phasecomp</a></code></h3>
<div class="sh3">

<h4>Usage:</h4>
<code><p>call <span class="b">phasecomp</span>(<span class="b">ffrec</span>, <span class="b">nphases</span>, <span class="b">phases</span>, weights=<span class="b">weights</span>, offset=<span class="b">offset</span>, firstphase=<span class="b">firstphase</span>)</p></code>

<h4>Description</h4>
<p>
Performs phase composites of S-T oscillatory field.
This field is typically a reconstructed pair of MSSA modes.
Composites are evaluated according to an index defined by the
first PC of the input field and its derivative. 
Space weights can be optionally used to compute the PC.
A minimal normalized amplitude can be also used: when the
index is under value, data are not used to compute phases.
It also possible so specify the angle of the first phase
in the 360 degrees phase diagram circle: zero means the
the first phase conincides with the maximmum.
</p>

<h4>Necessary arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>ffrec</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">		Space-time array</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>nphases</code></td>
		<td class="s" width="15%">[input,integer]:</td>
		<td width="70%">	Number of requested phases over the 360 degrees cycle (default = 8)</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>phases</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%"></td>
	</tr>
</table>

<h4>Optional arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>weights</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">	Space array of weights</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>offset</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">		Minimal normalized amplitude of the index (default = 0.)</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>firstphase</code></td>
		<td class="s" width="15%">[input,real]:</td>
		<td width="70%">	Value in degrees of the first phase (default = 0)</td>
	</tr>
</table>

<h4>Dependencies</h4>
<p>
<span class='b'><code><a href="#pca">pca</a></code></span>
</p>

</div>
<br />

<h3>Diagonalisation of a symetric matrix: <code><a name="diasym" class="b">diasym</a></code></h3>
<div class="sh3">

<h4>Usage:</h4>
<code><p>call <span class="b">diasym</span>(<span class="b">a</span>, <span class="b">eig</span>)</p></code>

<h4>Description</h4>
<p>
A simple interface to the ssyev diagonalisation subroutine from LAPACK.	
</p>

<h4>Necessary arguments</h4>

<table width="100%">
	<tr>
		<td class="b" width="15%"><code>a</code></td>
		<td class="s" width="15%">[inoutput,real]:</td>
		<td width="70%">		Input = symetric matrix, output = EOFs</td>
	</tr>
	<tr>
		<td class="b" width="15%"><code>eig</code></td>
		<td class="s" width="15%">[output,real]:</td>
		<td width="70%">	Eigen values</td>
	</tr>
</table>

<h4>Dependencies</h4>
<p>
<span class='b'><code><a href="#ssyev">ssyev</a>(<a href="#LAPACK">LAPACK</a>)</code></span>
</p>

</div>
<br />

<h2><a name="exam"></a>4. Example <a href="#top" class="top">[Top]</a></h2>

<code><p>

<span class="vi">program</span>&nbsp;example<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;This&nbsp;simple&nbsp;example&nbsp;shows&nbsp;how&nbsp;to&nbsp;use&nbsp;all&nbsp;subroutines&nbsp;from&nbsp;this&nbsp;package.</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Warning:&nbsp;it&nbsp;requires&nbsp;netcdf&nbsp;for&nbsp;in/outputs.</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;We&nbsp;start&nbsp;from&nbsp;longitude/latitude/time&nbsp;value&nbsp;of&nbsp;Pacific&nbsp;Sea&nbsp;Surface&nbsp;Temperature</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;that&nbsp;include&nbsp;the&nbsp;El&nbsp;Nino&nbsp;Southern&nbsp;Oscillation&nbsp;signal.</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Input&nbsp;is&nbsp;the&nbsp;netcdf&nbsp;file&nbsp;data.cdf.</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;We&nbsp;remove&nbsp;land&nbsp;points&nbsp;from&nbsp;the&nbsp;initial&nbsp;array&nbsp;according</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;to&nbsp;the&nbsp;netcdf&nbsp;missing_value&nbsp;attribute&nbsp;of&nbsp;the&nbsp;analysed&nbsp;variable&nbsp;(data&nbsp;are&nbsp;"packed").</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;A&nbsp;PCA&nbsp;is&nbsp;used&nbsp;to&nbsp;reduce&nbsp;the&nbsp;degrees&nbsp;of&nbsp;freedoom&nbsp;before&nbsp;MSSA&nbsp;analysis.</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Weights&nbsp;for&nbsp;PCA&nbsp;are&nbsp;computed&nbsp;as&nbsp;a&nbsp;fonction&nbsp;of&nbsp;latitude.</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Then,&nbsp;we&nbsp;assume&nbsp;that&nbsp;we&nbsp;have&nbsp;already&nbsp;identified&nbsp;an&nbsp;oscillation&nbsp;(after&nbsp;tests).</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;This&nbsp;oscillation,&nbsp;given&nbsp;by&nbsp;a&nbsp;pair&nbsp;of&nbsp;MSSA&nbsp;modes,&nbsp;is&nbsp;then&nbsp;</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;reconstructed&nbsp;from&nbsp;the&nbsp;MSSA&nbsp;and&nbsp;PCA&nbsp;spaces.</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Finally,&nbsp;phase&nbsp;composites&nbsp;are&nbsp;computed&nbsp;from&nbsp;this&nbsp;reconstructed&nbsp;oscillation.</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;The&nbsp;oscillation&nbsp;is&nbsp;outputed&nbsp;in&nbsp;a&nbsp;netcdf&nbsp;file&nbsp;(pair_1.cdf).</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;The&nbsp;initial&nbsp;data&nbsp;set&nbsp;(data.cdf):</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;origin:&nbsp;updated&nbsp;Reynolds&nbsp;and&nbsp;Smith&nbsp;(1996)&nbsp;SST&nbsp;(netcdf&nbsp;file)</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;origin&nbsp;url:&nbsp;data&nbsp;selector&nbsp;from&nbsp;http://iridl.ldeo.columbia.edu</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;how&nbsp;to&nbsp;get&nbsp;it&nbsp;[10Mb]:&nbsp;http://stefdeperou.free.fr/pub/data.cdf</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;area&nbsp;of&nbsp;study:&nbsp;tropical&nbsp;pacific&nbsp;[130.5E:75.5W,&nbsp;29.5S:29.5N]&nbsp;(155x60&nbsp;grid&nbsp;points)</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;period&nbsp;of&nbsp;study:&nbsp;Jan1982:Dec2005&nbsp;(288&nbsp;time&nbsp;steps)</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Parameters:</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;Only&nbsp;the&nbsp;first&nbsp;20&nbsp;PCs&nbsp;are&nbsp;retainedand&nbsp;given&nbsp;to&nbsp;the&nbsp;MSSA</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;A&nbsp;window&nbsp;of&nbsp;7&nbsp;years&nbsp;(84&nbsp;months)&nbsp;is&nbsp;chosen&nbsp;for&nbsp;the&nbsp;MSSA</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;Phase&nbsp;composites&nbsp;use&nbsp;8&nbsp;phases</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;An&nbsp;offset&nbsp;of&nbsp;0.4&nbsp;and&nbsp;is&nbsp;used&nbsp;for&nbsp;composites</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-&nbsp;The&nbsp;first&nbsp;phase&nbsp;of&nbsp;composites&nbsp;is&nbsp;set&nbsp;at&nbsp;180&nbsp;degrees&nbsp;(minimal&nbsp;value)</span><br />
&nbsp;&nbsp;&nbsp;<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="vi">use</span>&nbsp;<span class="b">pcamssa</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">use</span>&nbsp;netcdf<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="vi">implicit</span>&nbsp;<span class="gr">none</span><br />
&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Parameters</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;----------</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">integer</span>,<span class="gr">parameter</span>&nbsp;::&nbsp;nkeep_pca=<span class="r">5</span>,&nbsp;nwindow=<span class="r">84</span>,&nbsp;first_mode=<span class="r">1</span>,&nbsp;nphases=<span class="r">8</span><br />
<span class="e i">!&nbsp;&nbsp;&nbsp;integer,parameter&nbsp;::&nbsp;nkeep_pca=10,&nbsp;nwindow=36,&nbsp;first_mode=2,&nbsp;nphases=8</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">real</span>,&nbsp;<span class="gr">parameter</span>&nbsp;::&nbsp;offset=<span class="r">0</span>.,&nbsp;first_phase=<span class="r">180</span>.,&nbsp;new_missing_value=-<span class="r">999</span>.<br />
&nbsp;&nbsp;&nbsp;<span class="vi">character</span>(len=<span class="r">20</span>),&nbsp;<span class="gr">parameter</span>&nbsp;::&nbsp;input_nc_file="<span class="o">data.cdf</span>",&nbsp;output_nc_file="<span class="o">pair_1.nc</span>",&nbsp;&amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var_name="<span class="o">ssta</span>"<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Other&nbsp;declarations</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;------------------</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">real</span>,&nbsp;<span class="gr">allocatable</span>&nbsp;::&nbsp;field(:,:,:),&nbsp;weights(:,:),&nbsp;lat(:),&nbsp;lon(:),&nbsp;time(:)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">real</span>,&nbsp;<span class="gr">allocatable</span>&nbsp;::&nbsp;reco(:,:,:),&nbsp;phasecomps(:,:,:)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">logical</span>,&nbsp;<span class="gr">allocatable</span>&nbsp;::&nbsp;mask(:,:)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">real</span>,&nbsp;<span class="gr">allocatable</span>&nbsp;::&nbsp;packed_field(:,:),&nbsp;packed_weights(:),&nbsp;packed_phasecomps(:,:)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">real</span>,&nbsp;<span class="gr">allocatable</span>&nbsp;::&nbsp;eof(:,:),&nbsp;ev(:),&nbsp;pc(:,:),&nbsp;stpair(:,:),&nbsp;pair(:,:)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">real</span>,&nbsp;<span class="gr">allocatable</span>&nbsp;::&nbsp;steof(:,:),stpc(:,:),stev(:)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">character</span>(len=<span class="r">20</span>)&nbsp;::&nbsp;dim_names(<span class="r">3</span>),&nbsp;dim_name,&nbsp;lon_units,&nbsp;lat_units,&nbsp;var_units,&nbsp;&amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;&nbsp;&nbsp;lon_name,&nbsp;lat_name,&nbsp;time_name,&nbsp;time_units<br />
&nbsp;&nbsp;&nbsp;<span class="vi">integer</span>&nbsp;::&nbsp;ncid,&nbsp;dimid,&nbsp;dimids(<span class="r">4</span>),&nbsp;varid,&nbsp;dims(<span class="r">3</span>),&nbsp;thisdim,&nbsp;&amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;lonid,&nbsp;latid,&nbsp;phaseid,&nbsp;timeid,&nbsp;phcoid,&nbsp;recoid,&nbsp;origid<br />
&nbsp;&nbsp;&nbsp;<span class="vi">integer</span>(kind=<span class="r">4</span>)&nbsp;::&nbsp;i,&nbsp;nspace,&nbsp;nlon,&nbsp;nlat,&nbsp;ntime<br />
&nbsp;&nbsp;&nbsp;<span class="vi">real</span>&nbsp;::&nbsp;pi,&nbsp;missing_value<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Get&nbsp;the&nbsp;initial&nbsp;sst&nbsp;field&nbsp;from&nbsp;the&nbsp;netcdf&nbsp;file</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;----------------------------------------------</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">print</span>*,"<span class="o">Reading&nbsp;inputs...</span>"<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_open(input_nc_file,&nbsp;nf90_nowrite,&nbsp;ncid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_inq_varid(ncid,&nbsp;var_name,&nbsp;varid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_inquire_variable(ncid,&nbsp;varid,&nbsp;dimids=dimids(<span class="r">1</span>:<span class="r">4</span>)))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_inquire_dimension(ncid,&nbsp;dimids(<span class="r">1</span>),&nbsp;&amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;&nbsp;&nbsp;name=lon_name,&nbsp;len=nlon))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_inquire_dimension(ncid,&nbsp;dimids(<span class="r">2</span>),&nbsp;&amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;&nbsp;&nbsp;name=lat_name,&nbsp;len=nlat))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_inquire_dimension(ncid,&nbsp;dimids(<span class="r">3</span>),&nbsp;&amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;&nbsp;&nbsp;name=time_name,&nbsp;len=ntime))<br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(field(nlon,nlat,ntime))<br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(mask(nlon,nlat))<br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(weights(nlon,nlat))<br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(lon(nlon))<br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(lat(nlat))<br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(time(ntime))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_get_var(ncid,&nbsp;varid,&nbsp;field))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_get_att(ncid,&nbsp;varid,&nbsp;"<span class="o">missing_value</span>",&nbsp;missing_value))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_get_att(ncid,&nbsp;varid,&nbsp;"<span class="o">units</span>",&nbsp;var_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_inq_varid(ncid,&nbsp;lon_name,&nbsp;varid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_get_var(ncid,&nbsp;varid,&nbsp;lon))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_get_att(ncid,&nbsp;varid,&nbsp;"<span class="o">units</span>",&nbsp;lon_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_inq_varid(ncid,&nbsp;lat_name,&nbsp;varid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_get_var(ncid,&nbsp;varid,&nbsp;lat))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_get_att(ncid,&nbsp;varid,&nbsp;"<span class="o">units</span>",&nbsp;lat_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_inq_varid(ncid,&nbsp;time_name,&nbsp;varid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_get_var(ncid,&nbsp;varid,&nbsp;time))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_get_att(ncid,&nbsp;varid,&nbsp;"<span class="o">units</span>",&nbsp;time_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_close(ncid))<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Format&nbsp;(pack)&nbsp;data&nbsp;to&nbsp;have&nbsp;only&nbsp;one&nbsp;space&nbsp;dimension</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;---------------------------------------------------</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">print</span>*,"<span class="o">Packaging...</span>"<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Compute&nbsp;weights&nbsp;proportional&nbsp;to&nbsp;grid&nbsp;point&nbsp;area</span><br />
&nbsp;&nbsp;&nbsp;pi&nbsp;=&nbsp;cos(-<span class="r">1</span>.)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">do</span>&nbsp;i=<span class="r">1</span>,nlat<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weights(:,i)&nbsp;=&nbsp;cos(lat(i)*pi/<span class="r">180</span>.)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">end</span>&nbsp;<span class="vi">do</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!WARNING</span><br />
<span class="e i">!&nbsp;&nbsp;&nbsp;weights=50.</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Now&nbsp;pack</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">if</span>(isnan(missing_value))<span class="vi">then</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask&nbsp;=&nbsp;<span class="cy">not</span>(isnan(field(:,:,<span class="r">1</span>)))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask&nbsp;=&nbsp;(field(:,:,<span class="r">1</span>)&nbsp;/=&nbsp;missing_value)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">end</span>&nbsp;<span class="vi">if</span><br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(packed_field(count(mask),&nbsp;ntime))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">do</span>&nbsp;i=<span class="r">1</span>,&nbsp;ntime<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packed_field(:,i)&nbsp;=&nbsp;<span class="cy">pack</span>(field(:,:,i),&nbsp;mask)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">end</span>&nbsp;<span class="vi">do</span><br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(packed_weights(count(mask)))<br />
&nbsp;&nbsp;&nbsp;packed_weights&nbsp;=&nbsp;<span class="cy">pack</span>(weights,&nbsp;mask)<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Perform&nbsp;a&nbsp;PCA&nbsp;to&nbsp;reduce&nbsp;the&nbsp;d.o.f</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;---------------------------------</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">print</span>*,"<span class="o">PCA...</span>"<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;<span class="b">pca</span>(packed_field,&nbsp;nkeep=nkeep_pca,&nbsp;eof=eof,&nbsp;pc=pc,&nbsp;weights=packed_weights)<br />
&nbsp;&nbsp;&nbsp;<span class="cy">deallocate</span>(packed_field)<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;We&nbsp;send&nbsp;results&nbsp;from&nbsp;PCA&nbsp;to&nbsp;MSSA</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;--------------------------------</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">print</span>*,"<span class="o">MSSA...</span>"<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;<span class="b">mssa</span>(<span class="cy">transpose</span>(pc),&nbsp;nwindow,&nbsp;nkeep=first_mode+<span class="r">1</span>,&nbsp;steof=steof,&nbsp;stpc=stpc,&nbsp;ev=stev)<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;We&nbsp;reconstruct&nbsp;modes&nbsp;[first_mode&nbsp;+&nbsp;first_mode+1]&nbsp;of&nbsp;MSSA</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;--------------------------------------------------------</span><br />
&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;<span class="vi">print</span>*,"<span class="o">MSSAREC...</span>"<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;<span class="b">mssarec</span>(steof,&nbsp;stpc,&nbsp;nwindow,&nbsp;stpair,&nbsp;istart=first_mode,&nbsp;iend=first_mode+<span class="r">1</span>)<br />
&nbsp;&nbsp;&nbsp;<span class="cy">deallocate</span>(steof,&nbsp;stpc)<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="vi">print</span>*,"<span class="o">PCAREC...</span>"<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;<span class="b">pcarec</span>(eof,&nbsp;<span class="cy">transpose</span>(stpair),&nbsp;pair)<br />
<span class="e i">!&nbsp;&nbsp;&nbsp;call&nbsp;pcarec(eof,&nbsp;pc,&nbsp;pair)</span><br />
&nbsp;&nbsp;&nbsp;<span class="cy">deallocate</span>(stpair,&nbsp;eof)<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;We&nbsp;compute&nbsp;phases&nbsp;composites&nbsp;for&nbsp;the&nbsp;reconstructed&nbsp;oscillation</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;---------------------------------------------------------------</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">print</span>*,"<span class="o">PHASECOMP...</span>"<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;<span class="b">phasecomp</span>(pair,&nbsp;nphases,&nbsp;packed_phasecomps,&nbsp;weights=packed_weights,&nbsp;&amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;offset=offset,&nbsp;firstphase=first_phase)<br />
<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Unpacking</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;---------</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">print</span>*,"<span class="o">Unpacking...</span>"<br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(reco(nlon,nlat,ntime))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">do</span>&nbsp;i=<span class="r">1</span>,&nbsp;ntime<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reco(:,:,i)&nbsp;=&nbsp;<span class="cy">unpack</span>(pair(:,i),&nbsp;mask,&nbsp;new_missing_value)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where(mask&nbsp;==&nbsp;.false.)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field(:,:,i)&nbsp;=&nbsp;new_missing_value<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vi">end</span>&nbsp;where<br />
&nbsp;&nbsp;&nbsp;<span class="vi">end</span>&nbsp;<span class="vi">do</span><br />
&nbsp;&nbsp;&nbsp;<span class="cy">allocate</span>(phasecomps(nlon,nlat,nphases))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">do</span>&nbsp;i=<span class="r">1</span>,&nbsp;nphases<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phasecomps(:,:,i)&nbsp;=&nbsp;<span class="cy">unpack</span>(packed_phasecomps(:,i),&nbsp;mask,&nbsp;new_missing_value)<br />
&nbsp;&nbsp;&nbsp;<span class="vi">end</span>&nbsp;<span class="vi">do</span><br />
&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Write&nbsp;out&nbsp;the&nbsp;phase&nbsp;composites&nbsp;of&nbsp;the&nbsp;first&nbsp;oscillation</span><br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;-------------------------------------------------------</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">print</span>*,"<span class="o">Writing&nbsp;out...</span>"<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;File</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_create(output_nc_file,&nbsp;nf90_write,&nbsp;ncid))<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Dimensions</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_dim(ncid,&nbsp;"<span class="o">lon</span>",&nbsp;nlon,&nbsp;dimids(<span class="r">1</span>)))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_dim(ncid,&nbsp;"<span class="o">lat</span>",&nbsp;nlat,&nbsp;dimids(<span class="r">2</span>)))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_dim(ncid,&nbsp;"<span class="o">time</span>",&nbsp;ntime,&nbsp;dimids(<span class="r">3</span>)))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_dim(ncid,&nbsp;"<span class="o">phase</span>",&nbsp;nphases,&nbsp;dimids(<span class="r">4</span>)))<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Variables</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_var(ncid,&nbsp;"<span class="o">lon</span>",&nbsp;nf90_float,&nbsp;dimids(<span class="r">1</span>),&nbsp;lonid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;lonid,&nbsp;"<span class="o">long_name</span>",&nbsp;"<span class="o">Longitude</span>"))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;lonid,&nbsp;"<span class="o">units</span>",&nbsp;lon_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_var(ncid,&nbsp;"<span class="o">lat</span>",&nbsp;nf90_float,&nbsp;dimids(<span class="r">2</span>),&nbsp;latid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;latid,&nbsp;"<span class="o">long_name</span>",&nbsp;"<span class="o">Latitude</span>"))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;latid,&nbsp;"<span class="o">units</span>",&nbsp;lat_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_var(ncid,&nbsp;"<span class="o">time</span>",&nbsp;nf90_float,&nbsp;dimids(<span class="r">3</span>),&nbsp;timeid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;timeid,&nbsp;"<span class="o">long_name</span>",&nbsp;"<span class="o">Time</span>"))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;timeid,&nbsp;"<span class="o">units</span>",&nbsp;time_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_var(ncid,&nbsp;"<span class="o">phase</span>",&nbsp;nf90_float,&nbsp;dimids(<span class="r">4</span>),&nbsp;phaseid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;phaseid,&nbsp;"<span class="o">long_name</span>",&nbsp;"<span class="o">Phase</span>"))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;phaseid,&nbsp;"<span class="o">units</span>",&nbsp;"<span class="o">level</span>"))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_var(ncid,&nbsp;"<span class="o">orig</span>",&nbsp;nf90_float,&nbsp;dimids(<span class="r">1</span>:<span class="r">3</span>),&nbsp;origid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;origid,&nbsp;"<span class="o">long_name</span>",&nbsp;"<span class="o">SST&nbsp;anomaly&nbsp;/&nbsp;original&nbsp;field</span>"))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;origid,&nbsp;"<span class="o">units</span>",&nbsp;var_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;origid,&nbsp;"<span class="o">missing_value</span>",&nbsp;new_missing_value))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_var(ncid,&nbsp;"<span class="o">reco1</span>",&nbsp;nf90_float,&nbsp;dimids(<span class="r">1</span>:<span class="r">3</span>),&nbsp;recoid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;recoid,&nbsp;"<span class="o">long_name</span>",&nbsp;"<span class="o">SST&nbsp;anomaly&nbsp;/&nbsp;reconstruction&nbsp;of&nbsp;first&nbsp;pair</span>"))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;recoid,&nbsp;"<span class="o">units</span>",&nbsp;var_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;recoid,&nbsp;"<span class="o">missing_value</span>",&nbsp;new_missing_value))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_def_var(ncid,&nbsp;"<span class="o">pair1</span>",&nbsp;nf90_float,&nbsp;(/dimids(<span class="r">1</span>),dimids(<span class="r">2</span>),dimids(<span class="r">4</span>)/),&nbsp;phcoid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;phcoid,&nbsp;"<span class="o">long_name</span>",&nbsp;"<span class="o">SST&nbsp;anomaly&nbsp;/&nbsp;phase&nbsp;composite&nbsp;of&nbsp;first&nbsp;pair</span>"))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;phcoid,&nbsp;"<span class="o">units</span>",&nbsp;var_units))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_att(ncid,&nbsp;phcoid,&nbsp;"<span class="o">missing_value</span>",&nbsp;new_missing_value))<br />
&nbsp;&nbsp;&nbsp;<span class="e i">!&nbsp;Values</span><br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_enddef(ncid))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_var(ncid,&nbsp;lonid,&nbsp;lon))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_var(ncid,&nbsp;latid,&nbsp;lat))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_var(ncid,&nbsp;timeid,&nbsp;time))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_var(ncid,&nbsp;phaseid,&nbsp;float((/(i,i=<span class="r">1</span>,nphases)/))))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_var(ncid,&nbsp;origid,&nbsp;field))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_var(ncid,&nbsp;recoid,&nbsp;reco))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_put_var(ncid,&nbsp;phcoid,&nbsp;phasecomps))<br />
&nbsp;&nbsp;&nbsp;<span class="vi">call</span>&nbsp;err(nf90_close(ncid))<br />
<br />
<span class="vi">end</span>&nbsp;<span class="vi">program</span>&nbsp;example<br />
<br />
<span class="vi">subroutine</span>&nbsp;err(jstatus)<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="vi">use</span>&nbsp;netcdf<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="vi">integer</span>&nbsp;::&nbsp;jstatus<br />
<br />
&nbsp;&nbsp;&nbsp;<span class="vi">if</span>&nbsp;(jstatus&nbsp;.ne.&nbsp;nf90_noerr)&nbsp;<span class="vi">then</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vi">print</span>&nbsp;*,&nbsp;<span class="cy">trim</span>(nf90_strerror(jstatus))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stop<br />
&nbsp;&nbsp;&nbsp;<span class="vi">end</span>&nbsp;<span class="vi">if</span><br />
<br />
<span class="vi">end</span>&nbsp;<span class="vi">subroutine</span>&nbsp;err<br />
<br />
</p></code>

<h2><a name="refe"></a>5. References<a href="#top" class="top">[Top]</a></h2>
<ul>
	<li><a name="plva94"></a>Plaut, G. and R. Vautard, 1994: , J. Clim</li>
</ul>


<h2><a name="cont"></a>6. Contact<a href="#top" class="top">[Top]</a></h2>
stephane.raynaud@cea.fr


<hr>
<p class="i">Document generated by Perl (<a href="gendoc.pl"><code>gendoc.pl</code></a>)</p>

</body>
