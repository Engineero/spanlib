<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SpanLib - Fortran 90 library source</title><link rel="stylesheet" href="spanlib.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.61.2" /></head><body><div class="article" lang="en" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="id3305233"></a>SpanLib - Fortran 90 library source</h1></div></div><div></div><hr /></div><pre class="programlisting"><span class="HLcomments">! File: spanlib.f90</span>
<span class="HLcomments">!</span>
<span class="HLcomments">! This file is part of the SpanLib library.</span>
<span class="HLcomments">! Copyright (C) 2006  Stephane Raynaud</span>
<span class="HLcomments">! Contact: stephane dot raynaud at gmail dot com</span>
<span class="HLcomments">!</span>
<span class="HLcomments">! This library is free software; you can redistribute it and/or</span>
<span class="HLcomments">! modify it under the terms of the GNU Lesser General Public</span>
<span class="HLcomments">! License as published by the Free Software Foundation; either</span>
<span class="HLcomments">! version 2.1 of the License, or (at your option) any later version.</span>

<span class="HLcomments">! This library is distributed in the hope that it will be useful,</span>
<span class="HLcomments">! but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="HLcomments">! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="HLcomments">! Lesser General Public License for more details.</span>
<span class="HLcomments">!</span>
<span class="HLcomments">! You should have received a copy of the GNU Lesser General Public</span>
<span class="HLcomments">! License along with this library; if not, write to the Free Software</span>
<span class="HLcomments">! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</span>

<span class="HLpersonalised"></span><span class="HLroutines">module</span><span class="HLpersonalised"></span> <span class="HLpersonalised"></span>spanlib<span class="HLpersonalised"></span>

<span class="HLpersonalised"></span><span class="HLroutines">contains</span><span class="HLpersonalised"></span>

	<span class="HLcomments">! ############################################################</span>
	<span class="HLcomments">! ############################################################</span>
	<span class="HLcomments">! ## PCA PART ################################################</span>
	<span class="HLcomments">! ############################################################</span>
	<span class="HLcomments">! ############################################################</span>

	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_pca</span>(ff, nkeep, xeof, pc, ev, weights, useteof, bLargeMatrix)

	<span class="HLcomments">!	Principal Component Analysis</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description:</span>
	<span class="HLcomments">!	Perform a decomposition of space-time field in a set of</span>
	<span class="HLcomments">!	Empirical Orthogonal Functions (EOFs) and Principal components (PCs).</span>
	<span class="HLcomments">!	The input data set can be optionally weighted in space.</span>
	<span class="HLcomments">!	By default, the analysis computes  &quot;temporal&quot; (T) or classical</span>
	<span class="HLcomments">!	spatial (S) EOFs depending on if the space dimension is greater</span>
	<span class="HLcomments">!	than the time dimension. This default behavior can be overridden.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- ff:			Space-time array</span>
	<span class="HLcomments">!	- nkeep:		Maximum number of modes to keep in outputs</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Optional arguments:</span>
	<span class="HLcomments">!	- xeof:		Space-mode array of EOFs</span>
	<span class="HLcomments">!	- pc:			Time-mode array of PCs</span>
	<span class="HLcomments">!	- ev:			Mode array of eigen values (variances)</span>
	<span class="HLcomments">!	- weights:	Space array of weights</span>
	<span class="HLcomments">!	- useteof:	To force the use of T or S EOFs [0 = T, 1 = S, -1 = default]</span>
	<span class="HLcomments">!	- bLargeMatrix: Use la_syevd instead of la_syev (faster for large matrices, but uses more workspace) [default:.true.]</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Dependencies:</span>
	<span class="HLcomments">!	sgemm(BLAS) ssyrk(BLAS) la_syev(LAPACK95) la_syevd(LAPACK95)</span>


	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLroutines">use</span> la_precision, only: wp =&gt; sp
	<span class="HLroutines">use</span> f95_lapack, only: la_syevd, la_syev

	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! External</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(in)           :: ff(:,:)
	<span class="HLroutines">integer</span>, <span class="HLattributes">intent</span>(in)	         :: nkeep
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(out),<span class="HLattributes">optional</span> :: pc(size(ff,<span class="HLdigits">2</span>),nkeep), &amp;
	&amp;                                xeof(size(ff,<span class="HLdigits">1</span>),nkeep), ev(nkeep)
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: weights(:)
	<span class="HLroutines">integer</span>, <span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: useteof
	<span class="HLroutines">logical</span>, <span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: bLargeMatrix

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">integer</span>           :: ns,nt
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: cov(:,:), subcov(:,:)
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: wff(:,:), ww(:), zeof(:,:), zff(:,:)
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: zev(:)
	<span class="HLroutines">integer</span>           :: zuseteof, znkeepmax, i
	<span class="HLroutines">logical</span>           :: zbLargeMatrix

	<span class="HLcomments">! Setups</span>
	<span class="HLcomments">! ======</span>

	<span class="HLcomments">! Sizes</span>
	<span class="HLcomments">! -----</span>
	ns = size(ff,<span class="HLdigits">1</span>)
	nt = size(ff,<span class="HLdigits">2</span>)
	znkeepmax = <span class="HLdigits">100</span>
	<span class="HLroutines">if</span>(nkeep&gt;znkeepmax)<span class="HLroutines">then</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[pca] You want to keep a number of PCs '</span>//&amp;
		 &amp; <span class="HLstrings">'greater than '</span>,znkeepmax
		return
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! What does the user want?</span>
	<span class="HLcomments">! ------------------------</span>
	<span class="HLroutines">if</span>(.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(xeof).and..<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(pc)&amp;
	  &amp;.and..<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(ev))<span class="HLroutines">then</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[pca] Nothing to <span class="HLroutines">do</span>. Quit.'</span>
		return
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! By default, T-EOF decompostion if ns &gt; nt</span>
	<span class="HLcomments">! -----------------------------------------</span>
	zuseteof = -<span class="HLdigits">1</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(useteof))zuseteof = useteof
	<span class="HLroutines">if</span>(zuseteof&lt;=<span class="HLdigits">0</span>)<span class="HLroutines">then</span>
		<span class="HLroutines">if</span>(ns&gt;nt)<span class="HLroutines">then</span>
			zuseteof=<span class="HLdigits">1</span>
		<span class="HLroutines">else</span>
			zuseteof=<span class="HLdigits">0</span>
		<span class="HLroutines">endif</span>
	<span class="HLroutines">endif</span>
	znkeepmax=<span class="HLdigits">100</span>
	<span class="HLroutines">if</span>(zuseteof==<span class="HLdigits">1</span>)<span class="HLroutines">then</span>
		<span class="HLroutines">if</span>(nkeep&gt;nt)<span class="HLroutines">then</span>
			<span class="HLroutines">print</span>*,<span class="HLstrings">'[pca] You want to keep a number of PCs '</span>//&amp;
				&amp;<span class="HLstrings">'greater than the number of EOF:'</span>,nt
			return
		<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">else</span>
		<span class="HLroutines">if</span>(nkeep&gt;ns)<span class="HLroutines">then</span>
			<span class="HLroutines">print</span>*,<span class="HLstrings">'[pca] You want to keep a number of PCs '</span>//&amp;
				&amp;<span class="HLstrings">'greater than the number of EOF:'</span>,ns
			return
		<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Use ssyevd?</span>
	<span class="HLcomments">! -----------</span>
	<span class="HLroutines">if</span>(.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(bLargeMatrix))<span class="HLroutines">then</span>
		zbLargeMatrix = .true.
	<span class="HLroutines">else</span>
		zbLargeMatrix = bLargeMatrix
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Remove the mean</span>
	<span class="HLcomments">! ---------------</span>
	<span class="HLfunctions">allocate</span>(zff(ns,nt))
	zff = ff - <span class="HLfunctions">spread</span>(<span class="HLfunctions">sum</span>(ff,dim=<span class="HLdigits">2</span>)/<span class="HLroutines">real</span>(nt), ncopies=nt, dim=<span class="HLdigits">2</span>)


	<span class="HLcomments">! Default weights = 1.</span>
	<span class="HLcomments">! --------------------</span>
	<span class="HLfunctions">allocate</span>(ww(ns))
	<span class="HLfunctions">allocate</span>(wff(ns,nt))
	ww = <span class="HLdigits">1</span>.
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(weights))<span class="HLroutines">then</span>
		ww(:) = weights * <span class="HLroutines">real</span>(ns) / <span class="HLfunctions">sum</span>(weights)
		where(ww==<span class="HLdigits">0</span>.)ww = <span class="HLdigits">1</span>.
		<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, nt
			wff(:,i) = zff(:,i) * <span class="HLfunctions">sqrt</span>(ww)
		<span class="HLroutines">end</span> <span class="HLroutines">do</span>
	<span class="HLroutines">else</span>
		wff = zff
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>


	<span class="HLcomments">! EOF decomposition</span>
	<span class="HLcomments">! =================</span>

	<span class="HLroutines">if</span>(zuseteof==<span class="HLdigits">1</span>)<span class="HLroutines">then</span>


		<span class="HLcomments">! T-EOF case</span>
		<span class="HLcomments">! ----------</span>

		<span class="HLcomments">! Covariance</span>
		<span class="HLfunctions">allocate</span>(cov(nt,nt))
		<span class="HLfunctions">allocate</span>(zev(nt))
		cov=<span class="HLdigits">0</span>.
		<span class="HLroutines">call</span> ssyrk(<span class="HLstrings">'U'</span>,<span class="HLstrings">'T'</span>,nt,ns,<span class="HLdigits">1</span>.,wff,ns, <span class="HLdigits">0</span>.,cov,nt)
		cov = cov / float(ns)
		<span class="HLfunctions">deallocate</span>(wff)

		<span class="HLcomments">! Diagonalising (cov: input=cov, output=eof)</span>
		<span class="HLroutines">if</span>(zbLargeMatrix)<span class="HLroutines">then</span>
			<span class="HLroutines">call</span> la_syevd(cov,zev,jobz=<span class="HLstrings">'V'</span>)
		<span class="HLroutines">else</span>
			<span class="HLroutines">call</span> la_syev(cov,zev,jobz=<span class="HLstrings">'V'</span>)
		<span class="HLroutines">end</span> <span class="HLroutines">if</span>

		<span class="HLcomments">! Back to S-EOFs</span>
		<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(pc).or.<span class="HLfunctions">present</span>(xeof))<span class="HLroutines">then</span>
			<span class="HLfunctions">allocate</span>(zeof(ns,nkeep))
			<span class="HLfunctions">allocate</span>(subcov(nt,nkeep))
			subcov = cov(:,nt:nt-nkeep+<span class="HLdigits">1</span>:-<span class="HLdigits">1</span>)
			<span class="HLfunctions">deallocate</span>(cov)
			<span class="HLroutines">call</span> sgemm(<span class="HLstrings">'N'</span>,<span class="HLstrings">'N'</span>,ns,nkeep,nt,<span class="HLdigits">1</span>.,zff,ns, &amp;
				&amp; subcov,nt,<span class="HLdigits">0</span>.,zeof,ns)
			<span class="HLfunctions">deallocate</span>(subcov)
			<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, nkeep
				zeof(:,i) = zeof(:,i) / &amp;
				 &amp;          <span class="HLfunctions">sqrt</span>(<span class="HLfunctions">dot_product</span>(ww(:), zeof(:,i)**<span class="HLdigits">2</span>))
			<span class="HLroutines">end</span> <span class="HLroutines">do</span>
			<span class="HLroutines">if</span>(.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(pc)) <span class="HLfunctions">deallocate</span>(ww)
		<span class="HLroutines">else</span>
			<span class="HLfunctions">deallocate</span>(cov)
		<span class="HLroutines">end</span> <span class="HLroutines">if</span>

		<span class="HLcomments">! Eigenvalues</span>
		<span class="HLcomments">! -----------</span>
		<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(ev))ev = zev(nt:nt-nkeep+<span class="HLdigits">1</span>:-<span class="HLdigits">1</span>)

	<span class="HLroutines">else</span>

		<span class="HLcomments">! S-EOF case (classical)</span>
		<span class="HLcomments">! ----------------------</span>

		<span class="HLcomments">! Covariance</span>
		<span class="HLfunctions">allocate</span>(cov(ns,ns))
		<span class="HLfunctions">allocate</span>(zev(ns))
		cov = <span class="HLdigits">0</span>.
		<span class="HLroutines">call</span> ssyrk(<span class="HLstrings">'U'</span>,<span class="HLstrings">'N'</span>,ns,nt,<span class="HLdigits">1</span>.,wff,ns, <span class="HLdigits">0</span>.,cov,ns)
		cov = cov / float(nt)
		<span class="HLfunctions">deallocate</span>(wff)

		<span class="HLcomments">! Diagonalisation (cov: input=cov, output=eof)</span>
		<span class="HLroutines">if</span>(zbLargeMatrix)<span class="HLroutines">then</span>
			<span class="HLroutines">call</span> la_syevd(cov,zev,jobz=<span class="HLstrings">'V'</span>)
		<span class="HLroutines">else</span>
			<span class="HLroutines">call</span> la_syev(cov,zev,jobz=<span class="HLstrings">'V'</span>)
		<span class="HLroutines">end</span> <span class="HLroutines">if</span>

		<span class="HLcomments">! Formatting S-EOFs</span>
		<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(xeof).or.<span class="HLfunctions">present</span>(pc))<span class="HLroutines">then</span>
			<span class="HLfunctions">allocate</span>(zeof(ns,nkeep))
			<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, nkeep
				zeof(:,i) = cov(:,ns-i+<span class="HLdigits">1</span>) / <span class="HLfunctions">sqrt</span>(ww(:))
			<span class="HLroutines">end</span> <span class="HLroutines">do</span>
		<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	   <span class="HLfunctions">deallocate</span>(cov)

		<span class="HLcomments">! Eigenvalues</span>
		<span class="HLcomments">! -----------</span>
		<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(ev)) ev = zev(ns:ns-nkeep+<span class="HLdigits">1</span>:-<span class="HLdigits">1</span>)

	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Free eof array</span>
	<span class="HLcomments">! --------------</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(xeof))<span class="HLroutines">then</span>
		xeof = zeof
		<span class="HLroutines">if</span>(.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(pc)) <span class="HLfunctions">deallocate</span>(zeof)
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Finally get PCs</span>
	<span class="HLcomments">! ===============</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(pc))<span class="HLroutines">then</span>
		<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(weights))<span class="HLroutines">then</span>
			<span class="HLroutines">call</span> sl_pca_getec(zff,zeof,pc,weights=ww)
		<span class="HLroutines">else</span>
			<span class="HLroutines">call</span> sl_pca_getec(zff,zeof,pc)
		<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_pca</span>


	<span class="HLcomments">!############################################################</span>
	<span class="HLcomments">!############################################################</span>
	<span class="HLcomments">!############################################################</span>


	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_pca_getec</span>(ff, xeof, ec, weights)

	<span class="HLcomments">! Title:</span>
	<span class="HLcomments">!	Compute PCA expansion coefficients</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description</span>
	<span class="HLcomments">!	Get an expansion coefficients from a space-time field</span>
	<span class="HLcomments">!	and a set of EOFs computed by PCA. If the input</span>
	<span class="HLcomments">!	space-time field is the same as the one used to computes</span>
	<span class="HLcomments">!	input ST-EOFs, these expansion coincide with the</span>
	<span class="HLcomments">! associated principal components.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- ff:   Space-time field</span>
	<span class="HLcomments">!	- xeof: Spatial EOFs</span>
	<span class="HLcomments">!	- ec:   Time-mode array of expansion coefficients</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Optional arguments:</span>
	<span class="HLcomments">!	- weights: Space array of weights</span>

	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLcomments">! External</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(in)           :: ff(:,:), xeof(:,:)
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(out)          :: ec(size(ff,<span class="HLdigits">2</span>),size(xeof,<span class="HLdigits">2</span>))
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: weights(:)

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span> :: zweights(size(ff,<span class="HLdigits">1</span>)), zff(size(ff,<span class="HLdigits">1</span>),size(ff,<span class="HLdigits">2</span>))
	<span class="HLroutines">integer</span> :: ns,nt,nkeep,i

	<span class="HLcomments">! Computations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLcomments">! Initialisations</span>
	<span class="HLcomments">! ---------------</span>

	ns = size(ff,<span class="HLdigits">1</span>)
	nt = size(ff,<span class="HLdigits">2</span>)
	nkeep = size(xeof,<span class="HLdigits">2</span>)

	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(weights))<span class="HLroutines">then</span>
		zweights = weights
		<span class="HLroutines">do</span> i=<span class="HLdigits">1</span>, nt
			zff(:,i) = ff(:,i) * zweights
		<span class="HLroutines">end</span> <span class="HLroutines">do</span>
	<span class="HLroutines">else</span>
		zweights = <span class="HLdigits">1</span>.
		zff = ff
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Main stuff</span>
	<span class="HLcomments">! ----------</span>
	<span class="HLcomments">! ec = matmul( transpose(ff), xeof)</span>
	<span class="HLroutines">call</span> sgemm(<span class="HLstrings">'T'</span>,<span class="HLstrings">'N'</span>,nt,nkeep,ns,<span class="HLdigits">1</span>.,zff,ns, &amp;
		&amp; xeof,ns,<span class="HLdigits">0</span>.,ec,nt)
	<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, nkeep
		ec(:,i) = ec(:,i) / <span class="HLfunctions">dot_product</span>(xeof(:,i)**<span class="HLdigits">2</span>, zweights)
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_pca_getec</span>


	<span class="HLcomments">!############################################################</span>
	<span class="HLcomments">!############################################################</span>
	<span class="HLcomments">!############################################################</span>


	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_pca_rec</span>(xeof, pc, ffrec, istart, iend)

	<span class="HLcomments">! Title:</span>
	<span class="HLcomments">!	Reconstruction of a set of PCA components</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description:</span>
	<span class="HLcomments">!	Perform a reconstruction using a set of components previously</span>
	<span class="HLcomments">!	computed with a PCA. All the reconstructed components are summed.</span>
	<span class="HLcomments">!	A reconstructed component is simply the &quot;product&quot; of an EOF</span>
	<span class="HLcomments">!	by its PC. The sum of all reconstructed component is the original field.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- xeof:		Space-mode array of EOFs</span>
	<span class="HLcomments">!	- pc:		Time-mode array of PCs</span>
	<span class="HLcomments">!	- ffrec:	Space-time array of the reconstructed field</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Optional arguments:</span>
	<span class="HLcomments">!	- istart:	Index of the first component to use</span>
	<span class="HLcomments">!	- iend:		Index of the last component to use</span>


	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! External</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>,	<span class="HLattributes">intent</span>(in)              :: xeof(:,:), pc(:,:)
	<span class="HLroutines">real</span>,	<span class="HLattributes">intent</span>(out)             :: ffrec(size(xeof,<span class="HLdigits">1</span>),size(pc,<span class="HLdigits">1</span>))
	<span class="HLroutines">integer</span>,<span class="HLattributes">intent</span>(in),	<span class="HLattributes">optional</span>	:: istart, iend

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">integer</span>           :: nkept, itmp, zistart, ziend, nt, ns, i
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span>	:: zpc(:,:)


	<span class="HLcomments">! Setup</span>
	<span class="HLcomments">! =====</span>
	nkept = size(xeof,<span class="HLdigits">2</span>)
	zistart=<span class="HLdigits">1</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(istart))zistart=istart
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(iend))<span class="HLroutines">then</span>
		ziend=iend
	<span class="HLroutines">else</span>
		ziend=nkept
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">if</span>(zistart.lt.<span class="HLdigits">1</span>.or.zistart.gt.nkept)<span class="HLroutines">then</span>
		zistart=<span class="HLdigits">1</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[pca_rec] istart lower than <span class="HLdigits">1</span> =&gt; set to <span class="HLdigits">1</span>'</span>
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">if</span>(ziend.lt.<span class="HLdigits">1</span>.or.ziend.gt.nkept)<span class="HLroutines">then</span>
		ziend=nkept
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[pca_rec] iend greater than the number '</span>//&amp;
			&amp;<span class="HLstrings">'of avalaible modes =&gt; reduced to '</span>,ziend
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">if</span>(zistart&gt;ziend)<span class="HLroutines">then</span>
		itmp=ziend
		ziend=zistart
		zistart=itmp
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[pca_rec] istart &gt; iend =&gt; inversion'</span>
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	ns = size(xeof,<span class="HLdigits">1</span>)
	nt = size(pc,<span class="HLdigits">1</span>)

	<span class="HLcomments">! Computation</span>
	<span class="HLcomments">! ===========</span>
	ffrec = <span class="HLdigits">0</span>.
	<span class="HLroutines">if</span>(nt&lt;ns) <span class="HLroutines">then</span>
		<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, nt
			ffrec(:, i) = ffrec(:, i) + &amp;
				&amp;	<span class="HLfunctions">matmul</span>(xeof(:, zistart:ziend), pc(i, zistart:ziend))
		<span class="HLroutines">end</span> <span class="HLroutines">do</span>
	<span class="HLroutines">else</span>
		<span class="HLfunctions">allocate</span>(zpc(ziend-zistart+<span class="HLdigits">1</span>, nt))
		zpc = <span class="HLfunctions">transpose</span>(pc(:, zistart:ziend))
		<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, ns
			ffrec(i, :) = ffrec(i, :) + &amp;
				&amp;	<span class="HLfunctions">matmul</span>(xeof(i, zistart:ziend), zpc)
		<span class="HLroutines">end</span> <span class="HLroutines">do</span>
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_pca_rec</span>




  <span class="HLcomments">!############################################################</span>
  <span class="HLcomments">!############################################################</span>
  <span class="HLcomments">!## MSSA PART ###############################################</span>
  <span class="HLcomments">!############################################################</span>
  <span class="HLcomments">!############################################################</span>

	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_mssa</span>(ff, nwindow, nkeep, steof, stpc, ev, bLargeMatrix)

	<span class="HLcomments">! Title:</span>
	<span class="HLcomments">!	Multi-channel Singular Spectrum Analysis</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description:</span>
	<span class="HLcomments">!	Perform a decomposition of space-time field in a set of</span>
	<span class="HLcomments">!	space-time Empirical Orthogonal Functions (EOFs) and</span>
	<span class="HLcomments">!	time Principal components (PCs), according to a window</span>
	<span class="HLcomments">!	parameter.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- ff:      Space-time array</span>
	<span class="HLcomments">!	- nwindow: Window size</span>
	<span class="HLcomments">!	- nkeep:   Maximum number of modes to keep in outputs</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Optional arguments:</span>
	<span class="HLcomments">!	- steof: Space-window-mode array of EOFs</span>
	<span class="HLcomments">!	- stpc:  Time-mode array of PCs</span>
	<span class="HLcomments">!	- ev:    Mode array of eigen values (variances)</span>
	<span class="HLcomments">!	- bLargeMatrix: Use ssyevd instead of ssyev (faster for large matrices, but uses more workspace) [default:.true.]</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Dependencies:</span>
	<span class="HLcomments">!	la_syev(LAPACK95) la_syevd(LAPACK95)</span>


	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLroutines">use</span> la_precision, only: wp =&gt; sp
	<span class="HLroutines">use</span> f95_lapack, only: la_syevd, la_syev

	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! External</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>,   <span class="HLattributes">intent</span>(in)            :: ff(:,:)
	<span class="HLroutines">integer</span>,<span class="HLattributes">intent</span>(in)            :: nwindow, nkeep
	<span class="HLroutines">real</span>,   <span class="HLattributes">intent</span>(out), <span class="HLattributes">optional</span> :: steof(size(ff,<span class="HLdigits">1</span>)*nwindow, nkeep), &amp;
		&amp; stpc(size(ff,<span class="HLdigits">2</span>)-nwindow+<span class="HLdigits">1</span>, nkeep), ev(nkeep)
	<span class="HLroutines">logical</span>, <span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: bLargeMatrix

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: cov(:,:), zev(:), zff(:,:), zsteof(:,:)
	<span class="HLroutines">integer</span> :: nchan, nsteof, nt, znkeepmax
	<span class="HLroutines">integer</span> :: iw, iw1, iw2, i1, i2, ic1, ic2
	<span class="HLroutines">logical</span> :: zbLargeMatrix


	<span class="HLcomments">! Setup</span>
	<span class="HLcomments">! =====</span>

	<span class="HLcomments">! Sizes</span>
	<span class="HLcomments">! -----</span>
	nchan = size(ff,<span class="HLdigits">1</span>)
	nsteof = nchan * nwindow
	nt = size(ff,<span class="HLdigits">2</span>)
	znkeepmax = <span class="HLdigits">100</span>
	<span class="HLroutines">if</span>(nkeep&gt;znkeepmax)<span class="HLroutines">then</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[mssa] You want to keep a number of PCs '</span>//&amp;
		 &amp; <span class="HLstrings">'greater than '</span>,znkeepmax
		return
	<span class="HLroutines">else</span> <span class="HLroutines">if</span>(nkeep&gt;nsteof) <span class="HLroutines">then</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[mssa] You want to keep a number of PCs greater '</span>// &amp;
			&amp; <span class="HLstrings">'than the number of ST-EOFs:'</span>,nsteof
		return
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Use ssyevd?</span>
	<span class="HLcomments">! -----------</span>
	<span class="HLroutines">if</span>(.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(bLargeMatrix))<span class="HLroutines">then</span>
		zbLargeMatrix = .true.
	<span class="HLroutines">else</span>
		zbLargeMatrix = bLargeMatrix
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Remove the mean</span>
	<span class="HLcomments">! ---------------</span>
	<span class="HLfunctions">allocate</span>(zff(nchan, nt))
	zff = ff - <span class="HLfunctions">spread</span>(<span class="HLfunctions">sum</span>(ff,dim=<span class="HLdigits">2</span>)/<span class="HLroutines">real</span>(nt), ncopies=nt, dim=<span class="HLdigits">2</span>)

	<span class="HLcomments">! Set the block-Toeplitz covariance matrix</span>
	<span class="HLcomments">! ========================================</span>
	<span class="HLfunctions">allocate</span>(cov(nsteof, nsteof))
	<span class="HLroutines">do</span> ic1 = <span class="HLdigits">1</span>, nchan
		<span class="HLroutines">do</span> ic2 = <span class="HLdigits">1</span>, nchan
			<span class="HLroutines">do</span> iw2 = <span class="HLdigits">1</span>, nwindow
				<span class="HLroutines">do</span> iw1 = <span class="HLdigits">1</span>, iw2
					i1 = (ic1-<span class="HLdigits">1</span>) * nwindow + iw1
					i2 = (ic2-<span class="HLdigits">1</span>) * nwindow + iw2
					iw = iw2 - iw1 + <span class="HLdigits">1</span>
					cov(i1,i2) = &amp;
						&amp; <span class="HLfunctions">dot_product</span>(zff(ic1, <span class="HLdigits">1</span>  : nt-iw+<span class="HLdigits">1</span>),  &amp;
						&amp;             zff(ic2, iw : nt	 )) / &amp;
						&amp; <span class="HLroutines">real</span>(nt-iw+<span class="HLdigits">1</span>)
					cov(i2,i1) = cov(i1,i2)
				<span class="HLroutines">end</span> <span class="HLroutines">do</span>
			<span class="HLroutines">end</span> <span class="HLroutines">do</span>
		<span class="HLroutines">end</span> <span class="HLroutines">do</span>
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLcomments">! Diagonalisation</span>
	<span class="HLcomments">! ===============</span>
	<span class="HLfunctions">allocate</span>(zev(nsteof))
	<span class="HLroutines">if</span>(zbLargeMatrix)<span class="HLroutines">then</span>
		<span class="HLroutines">call</span> la_syevd(cov,zev,jobz=<span class="HLstrings">'V'</span>)
	<span class="HLroutines">else</span>
		<span class="HLroutines">call</span> la_syev(cov,zev,jobz=<span class="HLstrings">'V'</span>)
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>



	<span class="HLcomments">! Get ST-EOFs and eigenvalues</span>
	<span class="HLcomments">! ===========================</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(steof).or.<span class="HLfunctions">present</span>(stpc))<span class="HLroutines">then</span>
		<span class="HLfunctions">allocate</span>(zsteof(nsteof, nkeep))
		zsteof = cov(:, nsteof : nsteof-nkeep+<span class="HLdigits">1</span> : -<span class="HLdigits">1</span>)
		<span class="HLfunctions">deallocate</span>(cov)
		<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(steof))<span class="HLroutines">then</span>
			steof = zsteof
			<span class="HLfunctions">deallocate</span>(zsteof)
		<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Eigen values</span>
	<span class="HLcomments">! ------------</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(ev))<span class="HLroutines">then</span>
		ev = zev(nsteof : nsteof-nkeep+<span class="HLdigits">1</span> : -<span class="HLdigits">1</span>)
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLfunctions">deallocate</span>(zev)


	<span class="HLcomments">! Get ST-PCs</span>
	<span class="HLcomments">! ==========</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(stpc)) <span class="HLroutines">call</span> sl_mssa_getec(zff,steof,nwindow,stpc)
	<span class="HLfunctions">deallocate</span>(zff)

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_mssa</span>


	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_mssa_getec</span>(ff, steof, nwindow, stec)

	<span class="HLcomments">! Title:</span>
	<span class="HLcomments">!	Computes MSSA expansion coefficients</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description</span>
	<span class="HLcomments">!	Get an expansion coefficients from a space-time field</span>
	<span class="HLcomments">!	and a set of ST-EOFs computed by MSSA. If the input</span>
	<span class="HLcomments">!	space-time field is the same as the one used to computes</span>
	<span class="HLcomments">!	input ST-EOFs, these expansion coincide with the</span>
	<span class="HLcomments">! associated principal components.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- ff:   Space-time field</span>
	<span class="HLcomments">!	- steof: Space-window-mode EOFs</span>
	<span class="HLcomments">!	- stec:  Time-mode array of expansion coefficients</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Dependencies:</span>
	<span class="HLcomments">!	sgemm(BLAS)</span>

	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLcomments">! External</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(in)    :: ff(:,:), steof(:,:)
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(out)   :: stec(size(ff,<span class="HLdigits">2</span>)-nwindow+<span class="HLdigits">1</span>,size(steof,<span class="HLdigits">2</span>))
	<span class="HLroutines">integer</span>, <span class="HLattributes">intent</span>(in) :: nwindow

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">integer</span> :: nt,nkeep,im,iw,nchan
	<span class="HLroutines">real</span> :: wpc(size(ff,<span class="HLdigits">2</span>)-nwindow+<span class="HLdigits">1</span>), substeof(size(ff,<span class="HLdigits">1</span>)), &amp;
		&amp; subff(size(ff,<span class="HLdigits">1</span>),size(ff,<span class="HLdigits">2</span>)-nwindow+<span class="HLdigits">1</span>)

	<span class="HLcomments">! Computations</span>
	<span class="HLcomments">! ------------</span>

	<span class="HLcomments">! Initialisations</span>
	<span class="HLcomments">! ---------------</span>
	stec = <span class="HLdigits">0</span>.
	nchan = size(ff,<span class="HLdigits">1</span>)
	nt = size(ff,<span class="HLdigits">2</span>)
	nkeep = size(steof,<span class="HLdigits">2</span>)

	<span class="HLcomments">! Main stuff</span>
	<span class="HLcomments">! ----------</span>
	<span class="HLroutines">do</span> im = <span class="HLdigits">1</span>, nkeep
		<span class="HLroutines">do</span> iw = <span class="HLdigits">1</span>, nwindow
			subff = ff(:,iw:iw+nt-nwindow)
			substeof = steof(iw:iw+(nchan-<span class="HLdigits">1</span>)*nwindow:nwindow, im)
			<span class="HLroutines">call</span> sgemm(<span class="HLstrings">'T'</span>,<span class="HLstrings">'N'</span>, nt-nwindow+<span class="HLdigits">1</span>, <span class="HLdigits">1</span>, nchan, <span class="HLdigits">1</span>.,&amp;
				&amp; subff, nchan, substeof, nchan, <span class="HLdigits">0</span>., wpc, nt-nwindow+<span class="HLdigits">1</span>)
				stec(:, im)  =  stec(:, im) + wpc
		<span class="HLroutines">end</span> <span class="HLroutines">do</span>
		stec(:, im) = stec(:, im) / <span class="HLfunctions">sum</span>(steof(:,im)**<span class="HLdigits">2</span>)
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_mssa_getec</span>


	<span class="HLcomments">!############################################################</span>
	<span class="HLcomments">!############################################################</span>
	<span class="HLcomments">!############################################################</span>


	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_mssa_rec</span>(steof, stpc, nwindow, ffrec, istart, iend)

	<span class="HLcomments">! Title:</span>
	<span class="HLcomments">!	Reconstruction of a set of MSSA components</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description:</span>
	<span class="HLcomments">!	Same as for the reconstruction of PCA components, but for MSSA.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- steof:   SpaceXwindow-mode array of EOFs</span>
	<span class="HLcomments">!	- stpc:    Time-mode array of PCs</span>
	<span class="HLcomments">!	- nwindow: Window size</span>
	<span class="HLcomments">!	- ffrec:   Space-time array of the reconstructed field</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Optional arguments:</span>
	<span class="HLcomments">!	- istart: Index of the first component to use</span>
	<span class="HLcomments">!	- iend:   Index of the last component to use</span>

	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>


	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLcomments">! External</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>,   <span class="HLattributes">intent</span>(in)           :: steof(:,:), stpc(:,:)
	<span class="HLroutines">real</span>,   <span class="HLattributes">intent</span>(out)          :: ffrec(size(steof, <span class="HLdigits">1</span>)/nwindow,&amp;
	 &amp;                                    size(stpc, <span class="HLdigits">1</span>)+nwindow-<span class="HLdigits">1</span>)
	<span class="HLroutines">integer</span>,<span class="HLattributes">intent</span>(in)           :: nwindow
	<span class="HLroutines">integer</span>,<span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: istart, iend

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">integer</span> :: ntpc, nchan, nt, ic, im, iw, nkept, &amp;
	 &amp;         itmp, zistart, ziend
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: reof(:), epc(:,:)


	<span class="HLcomments">! Setup</span>
	<span class="HLcomments">! =====</span>

	<span class="HLcomments">! Sizes</span>
	<span class="HLcomments">! -----</span>
	ntpc  = size(stpc, <span class="HLdigits">1</span>)
	nt    = ntpc+nwindow-<span class="HLdigits">1</span>
	nchan = size(steof, <span class="HLdigits">1</span>)/nwindow
	nkept = size(steof, <span class="HLdigits">2</span>)
	<span class="HLfunctions">allocate</span>(reof(nwindow))
	<span class="HLfunctions">allocate</span>(epc(nwindow, ntpc-nwindow+<span class="HLdigits">1</span>))
	ffrec = <span class="HLdigits">0</span>.

	<span class="HLcomments">! Range</span>
	<span class="HLcomments">! -----</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(istart))zistart=istart
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(iend))<span class="HLroutines">then</span>
		ziend=iend
	<span class="HLroutines">else</span>
		ziend=nkept
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	zistart = <span class="HLdigits">1</span>
	<span class="HLroutines">if</span>(zistart.lt.<span class="HLdigits">1</span>.or.zistart.gt.nkept)<span class="HLroutines">then</span>
		zistart = <span class="HLdigits">1</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[mssa_rec] istart lower than <span class="HLdigits">1</span> =&gt; set to <span class="HLdigits">1</span>'</span>
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">if</span>(ziend.lt.<span class="HLdigits">1</span>.or.ziend.gt.nkept)<span class="HLroutines">then</span>
		ziend = nkept
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[mssa_rec] iend greater than the number of '</span>// &amp;
		 &amp;     <span class="HLstrings">'avalaible modes =&gt; reduced to'</span>,iend
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">if</span>(zistart&gt;ziend)<span class="HLroutines">then</span>
		itmp    = ziend
		ziend   = zistart
		zistart = itmp
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[mssa_rec] istart &gt; iend =&gt; inversion'</span>
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>


	<span class="HLcomments">! Computation</span>
	<span class="HLcomments">! ===========</span>
	ffrec = <span class="HLdigits">0</span>.
	<span class="HLroutines">do</span> im = zistart, ziend <span class="HLcomments">! sum over the selection of modes</span>

		<span class="HLcomments">! (ntpc-nwindow+1) length slices</span>
		<span class="HLroutines">do</span> iw = <span class="HLdigits">1</span>, nwindow
			epc(iw,:) = stpc(iw : iw+ntpc-nwindow, im)
		<span class="HLroutines">end</span> <span class="HLroutines">do</span>

		<span class="HLroutines">do</span> ic = <span class="HLdigits">1</span>, nchan <span class="HLcomments">! sum over the channels (= space or PCs from simple PCA)</span>

			<span class="HLcomments">! reversed eof</span>
			reof = steof(nwindow+(ic-<span class="HLdigits">1</span>)*nwindow : <span class="HLdigits">1</span>+(ic-<span class="HLdigits">1</span>)*nwindow : -<span class="HLdigits">1</span>, im)

			<span class="HLcomments">! * middle * [nwindow length projections]</span>
			ffrec(ic, nwindow : ntpc) =  ffrec(ic, nwindow : ntpc) + &amp;
				&amp; <span class="HLfunctions">matmul</span>(reof, epc) / <span class="HLroutines">real</span>(nwindow)

			<span class="HLroutines">do</span> iw = <span class="HLdigits">1</span>, nwindow-<span class="HLdigits">1</span>

			 <span class="HLcomments">! * beginning * [iw length projections]</span>
			 ffrec(ic, iw) = ffrec(ic, iw) + &amp;
				  &amp; <span class="HLfunctions">dot_product</span>(reof(nwindow-iw+<span class="HLdigits">1</span>:nwindow), &amp;
				  &amp;	stpc(<span class="HLdigits">1</span>:iw, im)           ) / <span class="HLroutines">real</span>(iw)
<span class="HLcomments">!</span>
			 <span class="HLcomments">! * end * [iw length projections]</span>
			 ffrec(ic, nt-iw+<span class="HLdigits">1</span>) = ffrec(ic, nt-iw+<span class="HLdigits">1</span>) + &amp;
				  &amp; <span class="HLfunctions">dot_product</span>(reof(<span class="HLdigits">1</span>:iw), &amp;
				  &amp;	stpc(ntpc-iw+<span class="HLdigits">1</span>:ntpc, im) ) / <span class="HLroutines">real</span>(iw)

			<span class="HLroutines">end</span> <span class="HLroutines">do</span>

		<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLfunctions">deallocate</span>(reof,epc)

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_mssa_rec</span>



  <span class="HLcomments">!############################################################</span>
  <span class="HLcomments">!############################################################</span>
  <span class="HLcomments">!## SVD PART ################################################</span>
  <span class="HLcomments">!############################################################</span>
  <span class="HLcomments">!############################################################</span>

	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_svd</span>(ll,rr,nkeep,leof,reof,lpc,rpc,ev,lw,rw,&amp;
		&amp; bLargeMatrix)

	<span class="HLcomments">! Title:</span>
	<span class="HLcomments">!	Singular Value Decomposition</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description:</span>
	<span class="HLcomments">!	Singular value decomposition between two datasets having</span>
	<span class="HLcomments">!	the same length in time.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- ll:    Left space-time array</span>
	<span class="HLcomments">!	- rr:    Right space-time array</span>
	<span class="HLcomments">!	- nkeep: Maximum number of modes to keep in outputs</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Optional arguments:</span>
	<span class="HLcomments">!	- leof:  Left EOFs</span>
	<span class="HLcomments">!	- reof:  Right EOFs</span>
	<span class="HLcomments">!	- lpc:   Left PCs</span>
	<span class="HLcomments">!	- rpc:   Right PCs</span>
	<span class="HLcomments">!	- ev:    Eigen values</span>
	<span class="HLcomments">!	- lw:    Left weights</span>
	<span class="HLcomments">!	- rw:    Right weights</span>
	<span class="HLcomments">!	- bLargeMatrix: Use la_sgesdd instead of la_sgesvd (faster for large matrices, but uses more workspace) [default:.false.]</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Dependencies:</span>
	<span class="HLcomments">!	sgemm(BLAS) la_gesvd(LAPACK95) la_gesdd(LAPACK95)</span>


	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLroutines">use</span> la_precision, only: wp =&gt; sp
	<span class="HLroutines">use</span> f95_lapack, only: la_gesdd, la_gesvd
	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! External</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(in)           :: ll(:,:),rr(:,:)
	<span class="HLroutines">integer</span>, <span class="HLattributes">intent</span>(in)	         :: nkeep
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: lw(:), rw(:)
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(out),<span class="HLattributes">optional</span> :: lpc(size(ll,<span class="HLdigits">2</span>),nkeep), &amp;
	&amp;                                leof(size(ll,<span class="HLdigits">1</span>),nkeep), &amp;
	&amp;                                rpc(size(rr,<span class="HLdigits">2</span>),nkeep), &amp;
	&amp;                                reof(size(rr,<span class="HLdigits">1</span>),nkeep), &amp;
	&amp;                                ev(nkeep)
	<span class="HLroutines">logical</span>, <span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: bLargeMatrix

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">integer</span>           :: ns,nsl,nsr,nt
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: zll(:,:), zrr(:,:), cov(:,:), zlw(:), zrw(:)
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: zev(:), zleof(:,:)
	<span class="HLroutines">integer</span>           :: znkeepmax, i
	<span class="HLroutines">logical</span>           :: zbLargeMatrix


	<span class="HLcomments">! Sizes</span>
	<span class="HLcomments">! -----</span>
	nsl = size(ll,<span class="HLdigits">1</span>)
	nsr = size(rr,<span class="HLdigits">1</span>)
	nt = size(ll,<span class="HLdigits">2</span>)
	<span class="HLroutines">if</span>(nsl/=nsr.or.nt/=size(rr,<span class="HLdigits">2</span>))<span class="HLroutines">then</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[svd] Left and right array have incompatible sizes'</span>
		return
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	ns = min(nsr,nsl)
	znkeepmax = <span class="HLdigits">100</span>
	<span class="HLroutines">if</span>(nkeep&gt;znkeepmax)<span class="HLroutines">then</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[svd] You want to keep a number of PCs '</span>//&amp;
		 &amp; <span class="HLstrings">'greater than '</span>,znkeepmax
		return
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">if</span>(nkeep&gt;ns)<span class="HLroutines">then</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[svd] You want to keep a number of PCs '</span>//&amp;
			&amp;<span class="HLstrings">'greater than the number of EOF:'</span>,ns
		return
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! What does the user want?</span>
	<span class="HLcomments">! ------------------------</span>
	<span class="HLroutines">if</span>(.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(leof).and..<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(lpc).and.&amp;
	  &amp;.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(reof).and..<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(rpc).and.&amp;
	  &amp;.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(ev))<span class="HLroutines">then</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'[svd] Nothing to <span class="HLroutines">do</span>. Quit.'</span>
		return
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Use ssyevd?</span>
	<span class="HLcomments">! -----------</span>
	<span class="HLroutines">if</span>(.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(bLargeMatrix))<span class="HLroutines">then</span>
		zbLargeMatrix = .false.
	<span class="HLroutines">else</span>
		zbLargeMatrix = bLargeMatrix
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Weights</span>
	<span class="HLcomments">! -------</span>
	<span class="HLfunctions">allocate</span>(zlw(nsl))
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(lw))<span class="HLroutines">then</span>
		zlw = lw * <span class="HLroutines">real</span>(nsl) / <span class="HLfunctions">sum</span>(lw)
		where(zlw==<span class="HLdigits">0</span>.) zlw = <span class="HLdigits">1</span>.
	<span class="HLroutines">else</span>
		zlw = <span class="HLdigits">1</span>.
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLfunctions">allocate</span>(zrw(nsl))
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(rw))<span class="HLroutines">then</span>
		zrw = rw * <span class="HLroutines">real</span>(nsr) / <span class="HLfunctions">sum</span>(rw)
		where(zrw==<span class="HLdigits">0</span>.) zrw = <span class="HLdigits">1</span>.
	<span class="HLroutines">else</span>
		zrw = <span class="HLdigits">1</span>.
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>


	<span class="HLcomments">! Computations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLcomments">! Remove the mean</span>
	<span class="HLcomments">! ---------------</span>
	<span class="HLfunctions">allocate</span>(zll(nsl,nt))
	zll = ll - <span class="HLfunctions">spread</span>(<span class="HLfunctions">sum</span>(ll,dim=<span class="HLdigits">2</span>)/<span class="HLroutines">real</span>(nt), ncopies=nt, dim=<span class="HLdigits">2</span>)
	<span class="HLfunctions">allocate</span>(zrr(nsr,nt))
	zrr = rr - <span class="HLfunctions">spread</span>(<span class="HLfunctions">sum</span>(rr,dim=<span class="HLdigits">2</span>)/<span class="HLroutines">real</span>(nt), ncopies=nt, dim=<span class="HLdigits">2</span>)

	<span class="HLcomments">! Weighting</span>
	<span class="HLcomments">! ---------</span>
	<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, nt
		zll(:,i) = zll(:,i) * <span class="HLfunctions">sqrt</span>(zlw)
		zrr(:,i) = zrr(:,i) * <span class="HLfunctions">sqrt</span>(zrw)
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLcomments">! Cross-covariances</span>
	<span class="HLcomments">! -----------------</span>
	<span class="HLfunctions">allocate</span>(cov(nsl,nsr))
	<span class="HLroutines">call</span> sgemm(<span class="HLstrings">'N'</span>,<span class="HLstrings">'T'</span>,nsl,nsr,nt,<span class="HLdigits">1</span>.,zll,nsl, &amp;
				&amp; zrr,nsr,<span class="HLdigits">0</span>.,cov,nsl)
	cov = cov / float(nt)
	<span class="HLroutines">if</span>(.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(lpc)) <span class="HLfunctions">deallocate</span>(zll)
	<span class="HLroutines">if</span>(.<span class="HLfunctions">not</span>.<span class="HLfunctions">present</span>(rpc)) <span class="HLfunctions">deallocate</span>(zrr)

	<span class="HLcomments">! SVD</span>
	<span class="HLcomments">! ---</span>
	<span class="HLfunctions">allocate</span>(zleof(nsr,ns), zev(ns))
	<span class="HLroutines">if</span>(zbLargeMatrix)<span class="HLroutines">then</span>
		<span class="HLroutines">call</span> la_gesdd(cov, zev, u=zleof, job=<span class="HLstrings">'V'</span>)
	<span class="HLroutines">else</span>
		<span class="HLroutines">call</span> la_gesvd(cov, zev, u=zleof, job=<span class="HLstrings">'V'</span>)
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>


	<span class="HLcomments">! Get output arrays</span>
	<span class="HLcomments">! =================</span>

	<span class="HLcomments">! Eigen values</span>
	<span class="HLcomments">! ------------</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(ev)) ev = zev(<span class="HLdigits">1</span>:nkeep)
	<span class="HLfunctions">deallocate</span>(zev)

	<span class="HLcomments">! EOFs</span>
	<span class="HLcomments">! ----</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(leof).or.<span class="HLfunctions">present</span>(lpc))<span class="HLroutines">then</span>
		leof = zleof(:,<span class="HLdigits">1</span>:nkeep)
		<span class="HLfunctions">deallocate</span>(zleof)
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(reof).or.<span class="HLfunctions">present</span>(rpc))<span class="HLroutines">then</span>
		<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, nkeep
			reof(:, i) = cov(i,:)
		<span class="HLroutines">end</span> <span class="HLroutines">do</span>
		<span class="HLfunctions">deallocate</span>(cov)
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! PCs</span>
	<span class="HLcomments">! ---</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(lpc))<span class="HLroutines">then</span>
		<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca_getec</span>(zll,leof,lpc,weights=zlw)
<span class="HLcomments">! 		if(present(lw))then</span>
<span class="HLcomments">! 			do i=1, nt</span>
<span class="HLcomments">! 				zll(:,i) = zll(:,i) * zlw</span>
<span class="HLcomments">! 			end do</span>
<span class="HLcomments">! 		end if</span>
<span class="HLcomments">! 		lpc = matmul(transpose(zll), leof)</span>
<span class="HLcomments">! 		do i = 1, nkeep</span>
<span class="HLcomments">! 			lpc(:,i) = lpc(:,i) / sum(leof(:,i)**2 * zlw)</span>
<span class="HLcomments">! 		end do</span>
		<span class="HLfunctions">deallocate</span>(zll)
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(rpc))<span class="HLroutines">then</span>
		<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca_getec</span>(zrr,reof,rpc,weights=zrw)
<span class="HLcomments">! 		if(present(rw))then</span>
<span class="HLcomments">! 			do i=1, nt</span>
<span class="HLcomments">! 				zrr(:,i) = zrr(:,i) * zlw</span>
<span class="HLcomments">! 			end do</span>
<span class="HLcomments">! 		end if</span>
<span class="HLcomments">! 		rpc = matmul(transpose(zrr), reof)</span>
<span class="HLcomments">! 		do i = 1, nkeep</span>
<span class="HLcomments">! 			rpc(:,i) = rpc(:,i) / sum(reof(:,i)**2 * zrw)</span>
<span class="HLcomments">! 		end do</span>
		<span class="HLfunctions">deallocate</span>(zrr)
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_svd</span>


	<span class="HLcomments">!############################################################</span>
	<span class="HLcomments">!############################################################</span>
	<span class="HLcomments">!############################################################</span>


	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_svd_model_build</span>(ll,rr,&amp;
		&amp; lPcaEof,rPcaEof,lSvdEof,rSvdEof,l2r,lPcaPc,rPcaPc)

	<span class="HLcomments">! Title:</span>
	<span class="HLcomments">!	SVD statistical model - Build part</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description:</span>
	<span class="HLcomments">!	Build a SVD-based statistical model to deduce right field</span>
	<span class="HLcomments">!	from left field. First, it performs pre-PCA on both dataset,</span>
	<span class="HLcomments">!	then it decomposes resulting PCs using a SVD.</span>
	<span class="HLcomments">!	Outputs EOFs and PCs from PCA and SVD can further be used</span>
	<span class="HLcomments">!	by the model part.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- ll:    Left space-time array</span>
	<span class="HLcomments">!	- rr:    Right space-time array</span>
	<span class="HLcomments">!	- nkeepPca: Maximum number pre-PCA of modes to retain</span>
	<span class="HLcomments">!	- nkeepSvd: Maximum number SVD of modes to retain</span>
	<span class="HLcomments">!	- lPcaEof:  Left pre-PCA EOFs</span>
	<span class="HLcomments">!	- rPcaEof:  Right pre-PCA EOFs</span>
	<span class="HLcomments">!	- lSvdEof:  Left pre-SVD EOFs</span>
	<span class="HLcomments">!	- rSvdEof:  Right pre-SVD EOFs</span>
	<span class="HLcomments">!	- l2r:      Scale factors to convert from left to right</span>


	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! External</span>
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(in) :: ll(:,:), rr(:,:)
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(out) ::lPcaEof(:,:), rPcaEof(:,:),&amp;
	 &amp; lsvdEof(:,:), rSvdEof(:,:), l2r(:)
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(out), <span class="HLattributes">optional</span> :: &amp;
	 &amp; lPcaPc(size(ll,<span class="HLdigits">2</span>),size(lPcaEof,<span class="HLdigits">2</span>)), &amp;
	 &amp; rPcaPc(size(ll,<span class="HLdigits">2</span>),size(rPcaEof,<span class="HLdigits">2</span>))

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">integer</span> :: i,nt,nkeepPca, nkeepSvd
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: zlSvdPc(:,:), zrSvdPc(:,:)

	<span class="HLcomments">! Sizes</span>
	<span class="HLcomments">! -----</span>
	nt = size(ll,<span class="HLdigits">2</span>)
	nkeepPca = size(lPcaEof,<span class="HLdigits">2</span>)
	nkeepSvd = size(lSvdEof,<span class="HLdigits">2</span>)


	<span class="HLcomments">! Computations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLcomments">! Pre-PCA</span>
	<span class="HLcomments">! -------</span>
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca</span>(ll, nkeepPca, xeof=lPcaEof, pc=lPcaPc)
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca</span>(rr, nkeepPca, xeof=rPcaEof, pc=rPcaPc)

	<span class="HLcomments">! SVD</span>
	<span class="HLcomments">! ---</span>
	<span class="HLfunctions">allocate</span>(zlSvdPc(nkeepSvd,nt),zrSvdPc(nkeepSvd,nt))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_svd</span>(<span class="HLfunctions">transpose</span>(lPcaPc),<span class="HLfunctions">transpose</span>(rPcaPc),nkeepSvd, &amp;
		&amp; leof=lSvdEof, reof=rSvdEof, lpc=zlSvdPc, rpc=zrSvdPc)

	<span class="HLcomments">! Scale factors</span>
	<span class="HLcomments">! -------------</span>
	<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, nkeepSVD
		l2r(i) = <span class="HLfunctions">sqrt</span>(<span class="HLfunctions">sum</span>(zrSvdPc(:,i)**<span class="HLdigits">2</span>)/<span class="HLfunctions">sum</span>(zlSvdPc(:,i)**<span class="HLdigits">2</span>))
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_svd_model_build</span>


	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_svd_model_use</span>(ll,rr,&amp;
		&amp; lPcaEof,rPcaEof,lSvdEof,rSvdEof,l2r)

 	<span class="HLcomments">! Title:</span>
	<span class="HLcomments">!	SVD statistical model - Use part</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description:</span>
	<span class="HLcomments">!	SVD-based statistical model to deduce right field</span>
	<span class="HLcomments">!	from left field. It uses results from pre-PCA</span>
	<span class="HLcomments">!	and SVD decompositions performed by sl_svdmodel_build.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- ll:    Left space array</span>
	<span class="HLcomments">!	- rr:    Right space array</span>
	<span class="HLcomments">!	- lPcaEof:  Left pre-PCA EOFs</span>
	<span class="HLcomments">!	- rPcaEof:  Right pre-PCA EOFs</span>
	<span class="HLcomments">!	- lSvdEof:  Left pre-SVD EOFs</span>
	<span class="HLcomments">!	- rSvdEof:  Right pre-SVD EOFs</span>
	<span class="HLcomments">!	- l2r:      Scale factors to convert from left to right</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Dependencies:</span>
	<span class="HLcomments">!	sl_pca_getec sl_pca_rec</span>


	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! External</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(in) :: ll(:), lPcaEof(:,:), rPcaEof(:,:),&amp;
	 &amp; lSvdEof(:,:), rSvdEof(:,:), l2r(:)
	<span class="HLroutines">real</span>, <span class="HLattributes">intent</span>(out) :: rr(:)

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">integer</span> :: i,nt,nkeepPca, nkeepSvd
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: zlPcaEc(:,:),zlSvdEc(:,:),zrSvdEc(:,:),&amp;
		&amp; zrPcaPc(:,:),zll(:,:),zrr(:,:)

	<span class="HLcomments">! Computations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLcomments">! Size</span>
	<span class="HLcomments">! ----</span>
	nt = <span class="HLdigits">1</span>
	nkeepPca = size(lPcaEof,<span class="HLdigits">2</span>)
	nkeepSvd = size(rSvdEof,<span class="HLdigits">2</span>)

	<span class="HLcomments">! Get expansion coefficients from re-PCA</span>
	<span class="HLcomments">! --------------------------------------</span>
	<span class="HLfunctions">allocate</span>(zll(size(ll,<span class="HLdigits">1</span>),<span class="HLdigits">1</span>),zlPcaEc(nt,nkeepPca))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca_getec</span>(zll,lPcaEof,zlPcaEc)
	<span class="HLfunctions">allocate</span>(zlSvdEc(nt,nkeepSvd))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca_getec</span>(lSvdEof,<span class="HLfunctions">transpose</span>(zlPcaEc),zlSvdEc)
	<span class="HLfunctions">deallocate</span>(zll,zlPcaEc)

	<span class="HLcomments">! Scale factorisation from left to right</span>
	<span class="HLcomments">! --------------------------------------</span>
	<span class="HLfunctions">allocate</span>(zrSvdEc(nt,nkeepSvd))
	<span class="HLroutines">do</span> i = <span class="HLdigits">1</span>, nkeepSvd
		zrSvdEc(:,i) = l2r(i) * zlSvdEc(:,i)
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>
	<span class="HLfunctions">deallocate</span>(zlSvdEc)

	<span class="HLcomments">! Reconstructions</span>
	<span class="HLcomments">! ---------------</span>
	<span class="HLfunctions">allocate</span>(zrPcaPc(nkeepPca,nt))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca_rec</span>(rSvdEof,zrSvdEc,zrPcaPc)
	<span class="HLfunctions">deallocate</span>(zrSvdEc)
	<span class="HLfunctions">allocate</span>(zrr(size(rr,<span class="HLdigits">1</span>),<span class="HLdigits">1</span>))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca_rec</span>(rPcaEof,<span class="HLfunctions">transpose</span>(zrPcaPc),zrr)
	rr = zrr(:,<span class="HLdigits">1</span>)
	<span class="HLfunctions">deallocate</span>(zrr,zrPcaPc)

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_svd_model_use</span>


  <span class="HLcomments">! ############################################################</span>
  <span class="HLcomments">! ############################################################</span>
  <span class="HLcomments">! ## TOOLS PART ##############################################</span>
  <span class="HLcomments">! ############################################################</span>
  <span class="HLcomments">! ############################################################</span>

	<span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_phasecomp</span>(ffrec,np,phases,weights,offset,firstphase)

	<span class="HLcomments">! Title:</span>
	<span class="HLcomments">!	Phase composites</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Description:</span>
	<span class="HLcomments">!	Performs phase composites of S-T oscillatory field.</span>
	<span class="HLcomments">!	This field is typically a reconstructed pair of MSSA modes.</span>
	<span class="HLcomments">!	Composites are evaluated according to an index defined by the</span>
	<span class="HLcomments">!	first PC of the input field and its derivative.</span>
	<span class="HLcomments">!	Space weights can be optionally used to compute the PC.</span>
	<span class="HLcomments">!	A minimal normalized amplitude can be also used: when the</span>
	<span class="HLcomments">!	index is under value, data are not used to compute phases.</span>
	<span class="HLcomments">!	It is also possible so specify the angle of the first phase</span>
	<span class="HLcomments">!	in the 360 degrees phase diagram circle: zero means the</span>
	<span class="HLcomments">!	the first phase conincides with the maximmum.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Necessary arguments:</span>
	<span class="HLcomments">!	- ffrec: Space-time array</span>
	<span class="HLcomments">!	- np:    Number of requested phases over the 360 degrees cycle [default:8]</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Optional arguments:</span>
	<span class="HLcomments">!	- weights:    Space array of weights</span>
	<span class="HLcomments">!	- offset:     Minimal normalized amplitude of the index [default:0.]</span>
	<span class="HLcomments">!	- firstphase: Value in degrees of the first phase [default:0.]</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Dependencies:</span>
	<span class="HLcomments">!	sl_pca</span>


	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! Declarations</span>
	<span class="HLcomments">! ============</span>

	<span class="HLcomments">! External</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">integer</span>, <span class="HLattributes">intent</span>(in)           :: np
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(in)           :: ffrec(:,:)
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: weights(:)
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(in), <span class="HLattributes">optional</span> :: offset, firstphase
	<span class="HLroutines">real</span>,    <span class="HLattributes">intent</span>(out)          :: phases(size(ffrec, <span class="HLdigits">1</span>),np)

	<span class="HLcomments">! Internal</span>
	<span class="HLcomments">! --------</span>
	<span class="HLroutines">real</span>, <span class="HLattributes">allocatable</span> :: pc(:,:)
	<span class="HLroutines">real</span> :: dpc(size(ffrec,<span class="HLdigits">2</span>)), amp(size(ffrec,<span class="HLdigits">2</span>))
	<span class="HLroutines">integer</span> :: nt, iphase
	<span class="HLroutines">real</span> :: angles(np), projection(size(ffrec,<span class="HLdigits">2</span>))
	<span class="HLroutines">real</span> :: pi, deltarad, pcos, psin, zoffset, zfirstphase
	<span class="HLroutines">logical</span> :: select_amplitude(size(ffrec,<span class="HLdigits">2</span>)), &amp;
	 &amp;         select_phase(size(ffrec,<span class="HLdigits">2</span>))
	<span class="HLroutines">integer</span> :: itime(size(ffrec,<span class="HLdigits">2</span>)), nsel, i, ns
	<span class="HLroutines">integer</span>, <span class="HLattributes">allocatable</span> :: isel(:)


	<span class="HLcomments">! Setup</span>
	<span class="HLcomments">! =====</span>
	nt = size(ffrec,<span class="HLdigits">2</span>)
	pi = acos(-<span class="HLdigits">1</span>.)
	itime = (/ (i, i=<span class="HLdigits">1</span>, nt) /)
	ns = size(ffrec, <span class="HLdigits">1</span>)
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(offset))<span class="HLroutines">then</span>
		zoffset=offset
	<span class="HLroutines">else</span>
		zoffset=<span class="HLdigits">0</span>.
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Find the first PC and its derivative</span>
	<span class="HLcomments">! ====================================</span>
	<span class="HLfunctions">allocate</span>(pc(nt,<span class="HLdigits">1</span>))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca</span>(ffrec, <span class="HLdigits">1</span>, pc=pc, weights=weights)
	pc = pc * <span class="HLfunctions">sqrt</span>(<span class="HLroutines">real</span>(nt)/<span class="HLfunctions">sum</span>(pc**<span class="HLdigits">2</span>))
	dpc = <span class="HLdigits">0</span>.<span class="HLdigits">5</span> * (<span class="HLfunctions">eoshift</span>(pc(:,<span class="HLdigits">1</span>),  <span class="HLdigits">1</span>, pc(nt,<span class="HLdigits">1</span>)) - &amp;
	 &amp;           <span class="HLfunctions">eoshift</span>(pc(:,<span class="HLdigits">1</span>), -<span class="HLdigits">1</span>, pc(<span class="HLdigits">1</span>,<span class="HLdigits">1</span>)))
	dpc((/<span class="HLdigits">1</span>,nt/)) = dpc((/<span class="HLdigits">1</span>,nt/)) * <span class="HLdigits">2</span>.
	dpc = dpc * <span class="HLfunctions">sqrt</span>(<span class="HLroutines">real</span>(nt)/<span class="HLfunctions">sum</span>(dpc**<span class="HLdigits">2</span>))
	amp = <span class="HLfunctions">sqrt</span>(pc(:,<span class="HLdigits">1</span>)**<span class="HLdigits">2</span> + dpc**<span class="HLdigits">2</span>)


	<span class="HLcomments">! Compute the maps</span>
	<span class="HLcomments">! ================</span>

	<span class="HLcomments">! Define the marks</span>
	<span class="HLcomments">! ----------------</span>
	deltarad = <span class="HLdigits">2</span> * pi / <span class="HLroutines">real</span>(np)
	<span class="HLroutines">if</span>(<span class="HLfunctions">present</span>(firstphase))<span class="HLroutines">then</span>
		zfirstphase = <span class="HLfunctions">modulo</span>(firstphase * <span class="HLdigits">2</span> * pi / <span class="HLdigits">360</span>., <span class="HLdigits">2</span> * pi)
	<span class="HLroutines">else</span>
	   zfirstphase = <span class="HLdigits">0</span>.
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	angles = (/ (<span class="HLroutines">real</span>(iphase), iphase=<span class="HLdigits">0</span>,np-<span class="HLdigits">1</span>) /) * deltarad + &amp;
	 &amp;       zfirstphase

	<span class="HLcomments">! Compute the phase maps</span>
	<span class="HLcomments">! ----------------------</span>
	phases = <span class="HLdigits">0</span>.
	select_amplitude = amp &gt;= zoffset
	<span class="HLroutines">do</span> iphase = <span class="HLdigits">1</span>, np
		pcos = cos(angles(iphase))
		psin = sin(angles(iphase))
		projection =  (pc(:,<span class="HLdigits">1</span>)*pcos+dpc*psin) / amp
		select_phase = ( projection &gt;= cos(<span class="HLdigits">0</span>.<span class="HLdigits">5</span>*deltarad) ) &amp;
		 &amp;             .and. select_amplitude
		<span class="HLroutines">if</span>(any(select_phase))<span class="HLroutines">then</span>
			nsel = count(select_phase)
			<span class="HLfunctions">allocate</span>(isel(nsel))
			isel = <span class="HLfunctions">pack</span>(itime, select_phase)
			phases(:,iphase) = <span class="HLfunctions">sum</span>(ffrec(:,isel), dim=<span class="HLdigits">2</span>) / <span class="HLroutines">real</span>(nsel)
			<span class="HLfunctions">deallocate</span>(isel)
		<span class="HLroutines">end</span> <span class="HLroutines">if</span>
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> <span class="HLpersonalised">sl_phasecomp</span>


<span class="HLroutines">end</span> <span class="HLroutines">module</span> spanlib
</pre></div></body></html>
