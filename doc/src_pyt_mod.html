<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SpanLib - Source of python module</title><link rel="stylesheet" href="spanlib.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.69.1" /></head><body><div class="article" lang="en" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="id2919820"></a>SpanLib - Source of python module</h1></div></div><hr /></div><pre class="programlisting"><span class="HLcomments">#################################################################################</span>
<span class="HLcomments"># File: spanlib_python.py</span>
<span class="HLcomments">#</span>
<span class="HLcomments"># This file is part of the SpanLib library.</span>
<span class="HLcomments"># Copyright (C) 2006  Charles Doutiraux, Stephane Raynaud</span>
<span class="HLcomments"># Contact: stephane dot raynaud at gmail dot com</span>
<span class="HLcomments">#</span>
<span class="HLcomments"># This library is free software; you can redistribute it and/or</span>
<span class="HLcomments"># modify it under the terms of the GNU Lesser General Public</span>
<span class="HLcomments"># License as published by the Free Software Foundation; either</span>
<span class="HLcomments"># version 2.1 of the License, or (at your option) any later version.</span>
<span class="HLcomments">#</span>
<span class="HLcomments"># This library is distributed in the hope that it will be useful,</span>
<span class="HLcomments"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="HLcomments"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="HLcomments"># Lesser General Public License for more details.</span>
<span class="HLcomments">#</span>
<span class="HLcomments"># You should have received a copy of the GNU Lesser General Public</span>
<span class="HLcomments"># License along with this library; if not, write to the Free Software</span>
<span class="HLcomments"># Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="HLcomments">#################################################################################</span>

<span class="HLpersonalised"></span><span class="HLcommands">import</span><span class="HLpersonalised"></span> <span class="HLpersonalised"></span>spanlib_fort<span class="HLpersonalised"></span>
<span class="HLpersonalised"></span><span class="HLcommands">import</span><span class="HLpersonalised"></span> <span class="HLpersonalised"></span>MV<span class="HLpersonalised"></span>
<span class="HLpersonalised"></span><span class="HLcommands">import</span><span class="HLpersonalised"></span> <span class="HLpersonalised"></span>Numeric<span class="HLpersonalised"></span>


<span class="HLcommands">def</span> <span class="HLpersonalised">stackData</span>(*data):
    <span class="HLcomments">""" Takes several data files, of same time and stacks them up together</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Description:::</span>
<span class="HLcomments">      This fonction concatenates several dataset that have the</span>
<span class="HLcomments">      same time axis. It is useful for analysing for example</span>
<span class="HLcomments">      several variables at the same time.</span>
<span class="HLcomments">      It takes into account weights, masks and axes.</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Usage:::</span>
<span class="HLcomments">    dout, weights, mask, axes = stackData(data1[, data2...])</span>
<span class="HLcomments"></span>
<span class="HLcomments">      *data   :: One or more data objects to stack.</span>
<span class="HLcomments">                 They must all have the same time length.</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Output:::</span>
<span class="HLcomments">      dout    :: Stacked data</span>
<span class="HLcomments">      weights :: Associated stacked weights</span>
<span class="HLcomments">      masks   :: Associated stacked masks</span>
<span class="HLcomments">      axes    :: Associated stacked axes</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments">    """</span>
    len_time=<span class="HLspecial">None</span>
    axes=[]
    dout=<span class="HLspecial">None</span> <span class="HLcomments"># data output</span>
    <span class="HLcommands">for</span> d <span class="HLcommands">in</span> data:
        t=d.getTime()
        <span class="HLcommands">if</span> t <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            raise <span class="HLstrings">'Error, all data muist have a time dimension'</span>
        <span class="HLcommands">if</span> len_time <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            len_time=len(t)
        elif len_time!=len(t):
            raise <span class="HLstrings">'Error all datasets must have the same time length!!!!'</span>

        <span class="HLcommands">if</span> d.getAxis(<span class="HLdigits">0</span>)!=t:
            d=d(order=<span class="HLstrings">'t...'</span>)

        axes.append(d.getAxisList())
        tdata,w,m=pack(d)
        <span class="HLcommands">if</span> dout <span class="HLcommands">is</span> <span class="HLspecial">None</span>: <span class="HLcomments"># Create</span>
            dout=tdata
            weights=w
            masks=[m]
        <span class="HLcommands">else</span>: <span class="HLcomments"># Append</span>
            dout=Numeric.concatenate((dout,tdata))
            weights=Numeric.concatenate((weights,w))
            masks.append(m)

    <span class="HLcommands">return</span> Numeric.transpose(dout),weights,masks,axes

<span class="HLcommands">def</span> <span class="HLpersonalised">unStackData</span>(din,weights,masks,axes):
    <span class="HLcomments">""" Unstack data in the form returned from stackData</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Description:::</span>
<span class="HLcomments">      This function is the reverse operation of stakData.</span>
<span class="HLcomments">      It splits stacked datasets into a list.</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Usage:::</span>
<span class="HLcomments">    dout = unStackData(din,weights,mask,axes)</span>
<span class="HLcomments"></span>
<span class="HLcomments">      din     :: Stacked data (see stackData function)</span>
<span class="HLcomments">      weights :: Associated stacked weights</span>
<span class="HLcomments">      masks   :: Associated stacked masks</span>
<span class="HLcomments">      axes    :: Associated stacked axes</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Output:::</span>
<span class="HLcomments">      dout    :: List of unstacked data</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments">    """</span>
    nvar=len(axes)

    <span class="HLcommands">if</span> nvar!=len(masks):
        raise <span class="HLstrings">'Error masks and input data length not compatible'</span>

    totsize=<span class="HLdigits">0</span>
    <span class="HLcommands">for</span> m <span class="HLcommands">in</span> masks:
        totsize+=<span class="HLfunctions">int</span>(MV.sum(MV.ravel(m)))
    <span class="HLcommands">if</span> totsize!=din.shape[<span class="HLdigits">1</span>]:
        raise <span class="HLstrings">'Error data and masks are not compatible <span class="HLcommands">in</span> length!!!! (%s) and (%s)'</span> % (totsize,din.shape[<span class="HLdigits">1</span>])

    istart=<span class="HLdigits">0</span>
    dout=[]
    <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(nvar):
        m=masks[i]
        mlen=<span class="HLfunctions">int</span>(MV.sum(MV.ravel(m)))
        iend=istart+mlen
        data=Numeric.transpose(din[:,istart:iend])
        w=weights[istart:iend]
        ns1=len(axes[i][-<span class="HLdigits">1</span>])
        ns2=len(axes[i][-<span class="HLdigits">2</span>])
        up=spanlib_fort.unpack3d(m,data,<span class="HLdigits">1</span>.e20)
        unpacked = MV.transpose(MV.array(up))
        unpacked = MV.masked_where(Numeric.equal(Numeric.resize(Numeric.transpose(m),unpacked.shape),<span class="HLdigits">0</span>),unpacked)
        unpacked.setAxisList(axes[i])
        istart+=mlen
        dout.append(unpacked)
    <span class="HLcommands">return</span> dout


<span class="HLcommands">def</span> <span class="HLpersonalised">pack</span>(data,weights=<span class="HLspecial">None</span>):
    <span class="HLcomments">""" Pack a dataset and its weights according to its mask</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Description:::</span>
<span class="HLcomments">      This function packs a dataset in 2D space by removing</span>
<span class="HLcomments">      all masked points and returning a space-time array.</span>
<span class="HLcomments">      It performs this operation also on the weights.</span>
<span class="HLcomments">      It is used for removing unnecessary points and</span>
<span class="HLcomments">      simplifying the input format for analysis functions.</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Usage:::</span>
<span class="HLcomments">    packed_data, packed_weights, mask = pack(data,weights)</span>
<span class="HLcomments"></span>
<span class="HLcomments">      data    :: Flatten in space an [x,y,t] array by removing</span>
<span class="HLcomments">                 its masked point</span>
<span class="HLcomments">      weights :: Weights to be flatten also</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Output:::</span>
<span class="HLcomments">      packed_data    :: Space-time packed array</span>
<span class="HLcomments">      packed_weights :: Packed weights that were guessed or used</span>
<span class="HLcomments">      mask           :: Mask that were guessed or used</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments">    """</span>
    <span class="HLcommands">if</span> Numeric.rank(data)==<span class="HLdigits">2</span>: <span class="HLcomments"># Already packed but then needs weights!</span>
        <span class="HLcommands">if</span> weights <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            raise <span class="HLstrings">'Error packed data must be sent with weights!'</span>
        <span class="HLcommands">else</span>:
            packed_data = Numeric.transpose(data)
            packed_weights = weights
            mask = <span class="HLspecial">None</span>
            <span class="HLcommands">return</span> packed_data,packed_weights,mask
    
    sh=<span class="HLfunctions">list</span>(data.shape)
<span class="HLcomments">##     ns1=sh[-1]</span>
<span class="HLcomments">##     ns2=sh[-2]</span>
<span class="HLcomments">##     nt=sh[0]</span>
    <span class="HLcomments">## Weights ?</span>
    <span class="HLcommands">if</span> weights <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
        <span class="HLcommands">try</span>:
            <span class="HLcommands">import</span> cdutil
            tmp=data
            while tmp.rank()&gt;<span class="HLdigits">2</span>:
                tmp=tmp[<span class="HLdigits">0</span>]
            weights=cdutil.area_weights(tmp).raw_data()
            del(tmp)
        <span class="HLcommands">except</span> Exception,err:
            weights=MV.ones((sh[-<span class="HLdigits">2</span>],sh[-<span class="HLdigits">1</span>]),typecode=<span class="HLstrings">'f'</span>)

    <span class="HLcomments">## Now masking part</span>
    <span class="HLcomments">## First from data</span>
    mask = data.mask()
    <span class="HLcommands">if</span> mask <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
        mask=MV.zeros(sh,typecode=<span class="HLstrings">'f'</span>)
    <span class="HLcommands">else</span>:
        mask=mask.astype(<span class="HLstrings">'i'</span>)
        
    <span class="HLcommands">if</span> data.rank()&gt;<span class="HLdigits">2</span>:
        mask=MV.sum(mask,axis=<span class="HLdigits">0</span>)

    <span class="HLcomments">## Now add the ones from the weights</span>
    mask=mask.filled()+MV.equal(weights,<span class="HLdigits">0</span>.).filled(<span class="HLdigits">1</span>)

    <span class="HLcomments">## &gt;=1 means masked, Fortran "mask": 1 means data ==&gt; 1-mask</span>
    mask=<span class="HLdigits">1</span>.-MV.greater_equal(mask,<span class="HLdigits">1</span>).filled()
    mask=Numeric.transpose(mask)

    <span class="HLcomments">## Number of points in spatial dimension</span>
    ns=<span class="HLfunctions">int</span>(MV.sum(Numeric.ravel(mask)))

    <span class="HLcomments">## Ok now calls fortran, but need to transpose first</span>
    packed_data=Numeric.transpose(data.filled(<span class="HLdigits">1</span>.e20))

    <span class="HLcomments">## Dummy 1D for time for tmask</span>
    <span class="HLcomments">## Pack data</span>
    packed_data = spanlib_fort.pack3d(packed_data,mask,ns)
    
    weights=MV.reshape(weights,(<span class="HLdigits">1</span>,sh[-<span class="HLdigits">2</span>],sh[-<span class="HLdigits">1</span>]))
    <span class="HLcomments">## Pack weights</span>
    tweights=Numeric.transpose(weights.filled(<span class="HLdigits">0</span>))
    tweights=Numeric.ones(tweights.shape,<span class="HLstrings">'f'</span>)
    packed_weights = spanlib_fort.pack3d(tweights,mask,ns)[:,<span class="HLdigits">0</span>].astype(<span class="HLstrings">'f'</span>)
    <span class="HLcommands">return</span> packed_data,packed_weights,mask


<span class="HLcommands">def</span> <span class="HLpersonalised">computePhases</span>(data,nphases=<span class="HLdigits">8</span>,offset=.<span class="HLdigits">5</span>,firstphase=<span class="HLdigits">0</span>):
    <span class="HLcomments">""" Phase composites for oscillatory fields</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Description:::</span>
<span class="HLcomments">      This computes temporal phase composites of a spatio-temporal</span>
<span class="HLcomments">      dataset. The dataset is expected to be oscillatory in time.</span>
<span class="HLcomments">      It corresponds to a reoganisation of the time axis to</span>
<span class="HLcomments">      to represents the dataset over its cycle in a arbitrary</span>
<span class="HLcomments">      number of phases. It is useful, for example, to have a</span>
<span class="HLcomments">      synthetic view of an reconstructed MSSA oscillation.</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Usage:::</span>
<span class="HLcomments">    phases = computePhases(data,nphases,offset,firstphase)</span>
<span class="HLcomments"></span>
<span class="HLcomments">      data       :: Space-time data oscillatory in time data.shape is rank 2 and dim 0 is space</span>
<span class="HLcomments">      nphases    :: Number of phases (divisions of the cycle)</span>
<span class="HLcomments">      offset     :: Normalised offset to keep higher values only [default:</span>
<span class="HLcomments">      firstphase :: Position of the first phase in the 360 degree cycle</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">    Output:::</span>
<span class="HLcomments">      phases :: Space-phase array</span>
<span class="HLcomments">    :::</span>
<span class="HLcomments">    """</span>

    ns=data.shape[<span class="HLdigits">0</span>]
    nt=data.shape[<span class="HLdigits">1</span>]
    w = MV.ones((ns),typecode=<span class="HLstrings">'f'</span>)
    phases = MV.array(spanlib_fort.phasecomp(data, nphases, w, offset, firstphase))
    axes = MV.array(data).getAxisList()
    phases.<span class="HLfunctions">id</span> = <span class="HLstrings">'phases'</span>
    ax = phases.getAxis(<span class="HLdigits">1</span>)
    ax[:]=ax[:]*<span class="HLdigits">360</span>./nphases+firstphase
    ax.<span class="HLfunctions">id</span> = <span class="HLstrings">'phases'</span>
<span class="HLcomments">##     print axes,ax,phases.shape</span>
    axes[<span class="HLdigits">1</span>] = ax
    phases.setAxisList(axes)
    <span class="HLcommands">return</span> phases

class <span class="HLpersonalised">SpAn</span>(object):
    <span class="HLcommands">def</span> __init__(<span class="HLspecial">self</span>,data,weights=<span class="HLspecial">None</span>,npca=<span class="HLspecial">None</span>,window=<span class="HLspecial">None</span>,nmssa=<span class="HLspecial">None</span>,nsvd=<span class="HLspecial">None</span>,relative=False):
        <span class="HLcomments">""" Prepare the Spectral Analysis Object</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Description:::</span>
<span class="HLcomments">          This function creates an object for future analyses.</span>
<span class="HLcomments">          It optionally initializes some parameters.</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Usage:::</span>
<span class="HLcomments">        analysis_object = SpAn(data,weights=None,npca=None,window=None,nmssa=None)</span>
<span class="HLcomments"></span>
<span class="HLcomments">          data    :: List of data on which to run the PC Analysis</span>
<span class="HLcomments">                     Last dimensions must represent the spatial dimensions.</span>
<span class="HLcomments">                     Analysis will be run on the first dimension.</span>
<span class="HLcomments">          weights :: If you which to apply weights on some points,</span>
<span class="HLcomments">                     set weights to "0" where you wish to mask.</span>
<span class="HLcomments">                     The input data mask will be applied,</span>
<span class="HLcomments">                     using the union of all none spacial dimension mask.</span>
<span class="HLcomments">                     If the data are on a regular grid, area weights</span>
<span class="HLcomments">                     will be generated, if the cdutil (CDAT) module is available.</span>
<span class="HLcomments">                     [default: 1. everywhere]</span>
<span class="HLcomments">          npca    :: Number of principal components to return [default: 10]</span>
<span class="HLcomments">          nmssa   :: Number of MSSA modes retained [default: 4]</span>
<span class="HLcomments">          nsvd    :: Number of SVD modes retained [default: 10]</span>
<span class="HLcomments">          window  :: MSSA window parameter [default: time_length/3.]</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Output:::</span>
<span class="HLcomments">          analysis_object :: SpAn object created for further analysis</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments">        """</span>
        <span class="HLcomments">## Sets all values to None</span>
        <span class="HLspecial">self</span>.clean()

        <span class="HLcomments">## Before all makes sure data is list of data</span>
        <span class="HLcommands">if</span> not isinstance(data,(<span class="HLfunctions">list</span>,tuple)):
            data=[data,]
        <span class="HLcommands">if</span> weights <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            weights=[<span class="HLspecial">None</span>,] * len(data)
        elif not isinstance(weights,(<span class="HLfunctions">list</span>,tuple)):
            weights = [weights,]
            
        <span class="HLcomments">## First pack our data, prepare the weights and mask for PCA</span>
        <span class="HLspecial">self</span>.pdata=[]
        <span class="HLspecial">self</span>.weights=[]
        <span class="HLspecial">self</span>.mask=[]
        <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(len(data)):
            d=data[i]
            w=weights[i]
            tmp = <span class="HLpersonalised">pack</span>(d,w)
            tmpdata,tmpweights,tmpmask = tmp
            <span class="HLspecial">self</span>.pdata.append(tmpdata)
            <span class="HLspecial">self</span>.weights.append(tmpweights)
            <span class="HLspecial">self</span>.mask.append(tmpmask)

        <span class="HLcomments">## Store axes for later</span>
        <span class="HLspecial">self</span>.axes=[]
        <span class="HLspecial">self</span>.varname=[]
        <span class="HLspecial">self</span>.grids=[]
        <span class="HLcommands">for</span> d <span class="HLcommands">in</span> data:
            <span class="HLspecial">self</span>.axes.append(d.getAxisList())
            <span class="HLspecial">self</span>.varname.append(d.<span class="HLfunctions">id</span>)
            <span class="HLspecial">self</span>.grids.append(d.getGrid())

        <span class="HLcomments">## Figures out length of time dimension</span>
        <span class="HLspecial">self</span>.nt = data[<span class="HLdigits">0</span>].shape[<span class="HLdigits">0</span>]
        
        <span class="HLcommands">for</span> d <span class="HLcommands">in</span> data:
            <span class="HLcommands">if</span> d.shape[<span class="HLdigits">0</span>] != <span class="HLspecial">self</span>.nt:
                raise Exception, <span class="HLstrings">'Error your dataset are not all consistent <span class="HLcommands">in</span> time length'</span>

        <span class="HLcommands">if</span> npca <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            <span class="HLspecial">self</span>.npca=<span class="HLdigits">10</span>
        <span class="HLcommands">else</span>:
            <span class="HLspecial">self</span>.npca=npca

        <span class="HLspecial">self</span>.ns=[]
        <span class="HLcommands">for</span> p <span class="HLcommands">in</span> <span class="HLspecial">self</span>.pdata:
            <span class="HLspecial">self</span>.ns.append(p.shape[<span class="HLdigits">0</span>])
            
        <span class="HLcommands">if</span> nmssa <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            <span class="HLspecial">self</span>.nmssa = <span class="HLdigits">4</span>
        <span class="HLcommands">else</span>:
            <span class="HLspecial">self</span>.nmssa = nmssa
            
        <span class="HLcommands">if</span> nsvd <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            <span class="HLspecial">self</span>.nsvd = <span class="HLdigits">10</span>
        <span class="HLcommands">else</span>:
            <span class="HLspecial">self</span>.nsvd = nsvd

        <span class="HLcommands">if</span> window <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            <span class="HLspecial">self</span>.window = <span class="HLfunctions">int</span>(<span class="HLspecial">self</span>.nt/<span class="HLdigits">3</span>.)
        <span class="HLcommands">else</span>:
            <span class="HLspecial">self</span>.window = window


    <span class="HLcommands">def</span> <span class="HLpersonalised">pca</span>(<span class="HLspecial">self</span>,npca=<span class="HLspecial">None</span>,get_ev_sum=False,relative=False):
        <span class="HLcomments">""" Principal Components Analysis (PCA)</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Descriptions:::</span>
<span class="HLcomments">          This function performs a PCA on the analysis objects</span>
<span class="HLcomments">          and returns EOF, PC and eigen values.</span>
<span class="HLcomments">          EOF are automatically unpacked.</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Usage:::</span>
<span class="HLcomments">        eof, pc, ev = pca(npca=None,weights=None,relative=False)</span>
<span class="HLcomments"></span>
<span class="HLcomments">        OR</span>
<span class="HLcomments"></span>
<span class="HLcomments">        eof, pc, ev, ev_sum = pca(npca=None,weights=None,get_ev_sum=True,relative=False)</span>
<span class="HLcomments"></span>
<span class="HLcomments">          npca    :: Number of principal components to return [default: 10]</span>
<span class="HLcomments">          get_ev_sum  :: Also return sum of all eigen values [default: False]</span>
<span class="HLcomments">          relative :: Egein values are normalized to their sum (%) [default: False]</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Output:::</span>
<span class="HLcomments">          eof    :: List EOF array (one per data input when created SpAn object)</span>
<span class="HLcomments">          pc     :: List of Principal Components array</span>
<span class="HLcomments">          ev     :: List of Eigein Values array</span>
<span class="HLcomments">          ev_sum :: Sum of all eigen values (even thoses not returned).</span>
<span class="HLcomments">                    Returned ONLY if get_ev_sum is True.</span>
<span class="HLcomments">                    It can also be retreived with &lt;SpAn_object&gt;.ev_sum.</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments">        """</span>

        <span class="HLcommands">if</span> npca <span class="HLcommands">is</span> not <span class="HLspecial">None</span>:
            <span class="HLspecial">self</span>.npca = npca
            

        <span class="HLcomments">## Calls Fortran pca</span>
        <span class="HLspecial">self</span>.eof=[]
        <span class="HLspecial">self</span>.pc=[]
        <span class="HLspecial">self</span>.ev=[]
        eof=[]
        pc=[]
        ev=[]
        <span class="HLspecial">self</span>.ev_sum=[]

        <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(len(<span class="HLspecial">self</span>.pdata)):
            pdat=<span class="HLspecial">self</span>.pdata[i]
            w=<span class="HLspecial">self</span>.weights[i]
            nteof,ntpc,ntev,ntev_sum = spanlib_fort.<span class="HLpersonalised">pca</span>(pdat,<span class="HLspecial">self</span>.npca,w,<span class="HLdigits">1</span>)

            Axes=<span class="HLfunctions">list</span>(<span class="HLspecial">self</span>.axes[i][<span class="HLdigits">1</span>:])

            <span class="HLcommands">if</span> <span class="HLspecial">self</span>.mask[i] <span class="HLcommands">is</span> not <span class="HLspecial">None</span>:
                teof = MV.transpose(MV.array(spanlib_fort.unpack3d(<span class="HLspecial">self</span>.mask[i],nteof,<span class="HLdigits">1</span>.e20)))
                teof = MV.masked_where(Numeric.equal(Numeric.resize(Numeric.transpose(<span class="HLspecial">self</span>.mask[i]),teof.shape),<span class="HLdigits">0</span>),teof)
                teof.<span class="HLfunctions">id</span>=<span class="HLstrings">'eof'</span>
                teof.name = teof.<span class="HLfunctions">id</span>
                teof.standard_name=<span class="HLstrings">'Empirical Orthogonal Functions'</span>
                teof.long_name = teof.standard_name
            <span class="HLcommands">else</span>:
                teof = MV.transpose(nteof)
                tpc  = MV.array(ntpc)

            ax=teof.getAxis(<span class="HLdigits">0</span>)
            ax.<span class="HLfunctions">id</span>=<span class="HLstrings">'mode'</span>
            ax.standard_name=<span class="HLstrings">'Modes <span class="HLcommands">in</span> decreasing order'</span>
            
            Axes.insert(<span class="HLdigits">0</span>,ax)
            teof.setAxisList(Axes)
            teof.setGrid(<span class="HLspecial">self</span>.grids[i])

            tpc=MV.transpose(MV.array(ntpc,axes=[<span class="HLspecial">self</span>.axes[i][<span class="HLdigits">0</span>],ax]))
            tpc.<span class="HLfunctions">id</span>=<span class="HLstrings">'pc'</span>
            tpc.standard_name=<span class="HLstrings">'Principal Components'</span>

            tev=MV.array(ntev,<span class="HLfunctions">id</span>=<span class="HLstrings">'ev'</span>,axes=[ax])
            tev.standard_name=<span class="HLstrings">'Eigen Values'</span>
            <span class="HLcommands">if</span> relative:
                tev[:] = tev[:] * <span class="HLdigits">100</span>. / ntev_sum
                tev.units = <span class="HLstrings">'%'</span>

            <span class="HLcommands">for</span> var <span class="HLcommands">in</span> tpc,tev,ax:
            	var.name = var.<span class="HLfunctions">id</span>
            	var.long_name = var.standard_name


            <span class="HLspecial">self</span>.pc.append(ntpc)
            <span class="HLspecial">self</span>.eof.append(nteof)
            eof.append(teof)
            pc.append(tpc)
            ev.append(tev)
            <span class="HLspecial">self</span>.ev_sum.append(ntev_sum)

        <span class="HLcommands">if</span> len(eof)==<span class="HLdigits">1</span>:
            ret =  [eof[<span class="HLdigits">0</span>],pc[<span class="HLdigits">0</span>],ev[<span class="HLdigits">0</span>]]
            <span class="HLspecial">self</span>.ev_sum = <span class="HLspecial">self</span>.ev_sum[<span class="HLdigits">0</span>]
        <span class="HLcommands">else</span>:
            ret =  [eof,pc,ev]

        <span class="HLcommands">if</span> get_ev_sum:
            ret.append(<span class="HLspecial">self</span>.ev_sum)

        <span class="HLcommands">return</span> ret
    

    <span class="HLcommands">def</span> <span class="HLpersonalised">mssa</span>(<span class="HLspecial">self</span>,nmssa=<span class="HLspecial">None</span>,<span class="HLpersonalised">pca</span>=<span class="HLspecial">None</span>,window=<span class="HLspecial">None</span>,get_ev_sum=False,relative=False):
        <span class="HLcomments">""" MultiChannel Singular Spectrum Analysis (MSSA)</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Descriptions:::</span>
<span class="HLcomments">          This function performs a MSSA on the analysis objects</span>
<span class="HLcomments">          and returns EOF, PC and eigen values.</span>
<span class="HLcomments">          Unless pca parameter is set to false, a pre</span>
<span class="HLcomments">          PCA is performed to reduced the number of d-o-f</span>
<span class="HLcomments">          if already done and if the number of channels is</span>
<span class="HLcomments">          greater than 30.</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Usage:::</span>
<span class="HLcomments">        eof, pc, ev = mssa(nmssa,pca,relative=False)</span>
<span class="HLcomments"></span>
<span class="HLcomments">        OR</span>
<span class="HLcomments"></span>
<span class="HLcomments">        eof, pc, ev, ev_sum = mssa(nmssa,pca,get_ev_sum=True,relative=False)</span>
<span class="HLcomments"></span>
<span class="HLcomments">          nmssa  :: Number of MSSA modes retained</span>
<span class="HLcomments">          window :: MSSA window parameter</span>
<span class="HLcomments">          pca    :: If True, performs a preliminary PCA</span>
<span class="HLcomments">          get_ev_sum  :: Also return sum of all eigen values (default: False)</span>
<span class="HLcomments">          relative :: Egein values are normalized to their sum (%) [default: False]</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Output:::</span>
<span class="HLcomments">          eof :: EOF array</span>
<span class="HLcomments">          pc  :: Principal Components array</span>
<span class="HLcomments">          ev  :: Eigen Values  array</span>
<span class="HLcomments">          ev_sum :: Sum of all eigen values (even thoses not returned).</span>
<span class="HLcomments">                    Returned ONLY if get_ev_sum is True.</span>
<span class="HLcomments">                    It can also be retreived with &lt;SpAn_object&gt;.stev_sum.</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments">        """</span>

        <span class="HLcomments">## Check for default values for mssa and pca if not passed by user</span>
        <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span> <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            <span class="HLcommands">if</span> <span class="HLspecial">self</span>.pc ==[] and max(<span class="HLdigits">0</span>,<span class="HLspecial">self</span>.ns) &gt; <span class="HLdigits">30</span>: <span class="HLcomments"># Pre-PCA needed</span>
                <span class="HLcommands">print</span> <span class="HLstrings">'[<span class="HLpersonalised">mssa</span>] The number of valid points <span class="HLcommands">is</span> greater than'</span>,<span class="HLdigits">30</span>,<span class="HLstrings">' so we perform a pre-<span class="HLpersonalised">PCA</span>'</span>
                <span class="HLpersonalised">pca</span> = <span class="HLspecial">True</span>
            elif <span class="HLspecial">self</span>.pc <span class="HLcommands">is</span> not <span class="HLspecial">None</span>:
                <span class="HLpersonalised">pca</span> = <span class="HLspecial">True</span>
            <span class="HLcommands">else</span>:
                <span class="HLpersonalised">pca</span> = False

        <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span> <span class="HLcommands">is</span> <span class="HLspecial">True</span>: <span class="HLcomments"># From PCA to MSSA</span>
            nspace = [<span class="HLspecial">self</span>.npca,]*len(<span class="HLspecial">self</span>.pdata)
            <span class="HLcommands">if</span> <span class="HLspecial">self</span>.pc ==[]: <span class="HLcomments"># Still no PCA done</span>
                <span class="HLspecial">self</span>.<span class="HLpersonalised">pca</span>()
        <span class="HLcommands">else</span>:
            nspace = <span class="HLspecial">self</span>.ns

        <span class="HLcommands">if</span> nmssa <span class="HLcommands">is</span> not <span class="HLspecial">None</span>:
            <span class="HLspecial">self</span>.nmssa = nmssa

        <span class="HLcommands">if</span> window <span class="HLcommands">is</span> not <span class="HLspecial">None</span>:
            <span class="HLspecial">self</span>.window = window

        <span class="HLspecial">self</span>.steof = []
        <span class="HLspecial">self</span>.stpc  = []

        eof=[]
        ev=[]
        pc=[]
        <span class="HLspecial">self</span>.stev_sum=[]
        
        <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(len(<span class="HLspecial">self</span>.pdata)):
            <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span> <span class="HLcommands">is</span> <span class="HLspecial">True</span>: <span class="HLcomments"># Pre-PCA case</span>
                ntsteof, ntstpc, ntstev, ntev_sum = spanlib_fort.<span class="HLpersonalised">mssa</span>(Numeric.transpose(<span class="HLspecial">self</span>.pc[i]), <span class="HLspecial">self</span>.window, <span class="HLspecial">self</span>.nmssa)
            <span class="HLcommands">else</span>: <span class="HLcomments"># Direct MSSA case</span>
                ntsteof, ntstpc, ntstev, ntev_sum = spanlib_fort.<span class="HLpersonalised">mssa</span>(<span class="HLspecial">self</span>.pdata[i], <span class="HLspecial">self</span>.window, <span class="HLspecial">self</span>.nmssa)


            teof = MV.transpose(MV.reshape(ntsteof,(<span class="HLspecial">self</span>.window,nspace[i],<span class="HLspecial">self</span>.nmssa)))
            teof.<span class="HLfunctions">id</span>=<span class="HLstrings">'eof'</span>
            teof.standard_name=<span class="HLstrings">'Empirical Orthogonal Functions'</span>

            ax0=teof.getAxis(<span class="HLdigits">0</span>)
            ax0.<span class="HLfunctions">id</span>=<span class="HLstrings">'space'</span>
            ax0.standard_name=<span class="HLstrings">'Space'</span>

            ax1=teof.getAxis(<span class="HLdigits">1</span>)
            ax1.<span class="HLfunctions">id</span>=<span class="HLstrings">'mode'</span>
            ax1.standard_name=<span class="HLstrings">'Modes <span class="HLcommands">in</span> decreasing order'</span>

            ax2=teof.getAxis(<span class="HLdigits">2</span>)
            ax2.<span class="HLfunctions">id</span>=<span class="HLstrings">'window'</span>
            ax2.standard_name=<span class="HLstrings">'Window Axis'</span>

            tpc=MV.transpose(MV.array(ntstpc))
            tpc.<span class="HLfunctions">id</span>=<span class="HLstrings">'pc'</span>
            tpc.standard_name=<span class="HLstrings">'Principal Components'</span>
            tpc.setAxis(<span class="HLdigits">0</span>,ax0)

            ax3 = tpc.getAxis(<span class="HLdigits">1</span>)
            ax3.<span class="HLfunctions">id</span>=<span class="HLstrings">'time'</span>
            ax3.standard_name = <span class="HLstrings">'Time'</span>
            
            tev = MV.array(ntstev,<span class="HLfunctions">id</span>=<span class="HLstrings">'ev'</span>,axes=[ax0])
            tev.standard_name = <span class="HLstrings">'Eigen Values'</span>
            tev.<span class="HLfunctions">id</span> = <span class="HLstrings">'ev'</span>
            <span class="HLcommands">if</span> relative:
                tev[:] = tev[:] * <span class="HLdigits">100</span>. / ntev_sum
                tev.units = <span class="HLstrings">'%'</span>
            
            <span class="HLcommands">for</span> var <span class="HLcommands">in</span> teof,tpc,tev,ax0,ax1,ax2,ax3:
            	var.name = var.<span class="HLfunctions">id</span>
            	var.long_name = var.standard_name

            <span class="HLspecial">self</span>.stpc.append(ntstpc)
            <span class="HLspecial">self</span>.steof.append(ntsteof)
            eof.append(teof)
            pc.append(tpc)
            ev.append(tev)
            <span class="HLspecial">self</span>.stev_sum.append(ntev_sum)

        <span class="HLcommands">if</span> len(eof)==<span class="HLdigits">1</span>:
            ret = [eof[<span class="HLdigits">0</span>],pc[<span class="HLdigits">0</span>],ev[<span class="HLdigits">0</span>]]
            <span class="HLspecial">self</span>.stev_sum = <span class="HLspecial">self</span>.stev_sum[<span class="HLdigits">0</span>]
        <span class="HLcommands">else</span>:
            ret = [eof,pc,ev]

        <span class="HLcommands">if</span> get_ev_sum:
            ret.append(<span class="HLspecial">self</span>.ev_sum)

        <span class="HLcommands">return</span> ret
    

    <span class="HLcommands">def</span> <span class="HLpersonalised">svd</span>(<span class="HLspecial">self</span>,nsvd=<span class="HLspecial">None</span>,<span class="HLpersonalised">pca</span>=<span class="HLspecial">None</span>):
        <span class="HLcomments">""" Singular Value Decomposition (SVD)</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Descriptions:::</span>
<span class="HLcomments">          This function performs a SVD</span>
<span class="HLcomments">          ---blabla---</span>
<span class="HLcomments">          and returns EOF, PC and eigen values.</span>
<span class="HLcomments">          Unless pca parameter is set to false, a pre</span>
<span class="HLcomments">          PCA is performed to reduced the number of d-o-f</span>
<span class="HLcomments">          if already done and if the number of channels is</span>
<span class="HLcomments">          greater than 30.</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Usage:::</span>
<span class="HLcomments">        eof, pc, ev = mssa(nmssa,pca)</span>
<span class="HLcomments"></span>
<span class="HLcomments">          nmssa  :: Number of MSSA modes retained</span>
<span class="HLcomments">          window :: MSSA window parameter</span>
<span class="HLcomments">          pca    :: If True, performs a preliminary PCA</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Output:::</span>
<span class="HLcomments">          eof :: EOF array</span>
<span class="HLcomments">          pc  :: Principal Components array</span>
<span class="HLcomments">          ev  :: Eigen Values  array</span>
<span class="HLcomments"></span>
<span class="HLcomments">        ---blabla---</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments">        """</span>

        <span class="HLcomments">## Check we have at least 2 variables!!</span>
        <span class="HLcomments">## At the moment we will not use any more variable</span>
        <span class="HLcommands">if</span> len(<span class="HLspecial">self</span>.pdata)&lt;<span class="HLdigits">2</span>:
            raise Exception,<span class="HLstrings">'Error you need at least (most) <span class="HLdigits">2</span> datasets to run <span class="HLpersonalised">svd</span>, otherwise use <span class="HLpersonalised">pca</span> and <span class="HLpersonalised">mssa</span>'</span>
        
        <span class="HLcomments">## Check for default values for mssa and pca if not passed by user</span>
        <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span> <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            <span class="HLcommands">if</span> <span class="HLspecial">self</span>.pc ==[] and max(<span class="HLdigits">0</span>,<span class="HLspecial">self</span>.ns) &gt; <span class="HLdigits">30</span>: <span class="HLcomments"># Pre-PCA needed</span>
                <span class="HLcommands">print</span> <span class="HLstrings">'[<span class="HLpersonalised">svd</span>] The number of valid points <span class="HLcommands">is</span> greater than'</span>,<span class="HLdigits">30</span>,<span class="HLstrings">' so we perform a pre-<span class="HLpersonalised">PCA</span>'</span>
                <span class="HLpersonalised">pca</span> = <span class="HLspecial">True</span>
            elif <span class="HLspecial">self</span>.pc <span class="HLcommands">is</span> not <span class="HLspecial">None</span>:
                <span class="HLpersonalised">pca</span> = <span class="HLspecial">True</span>
            <span class="HLcommands">else</span>:
                <span class="HLpersonalised">pca</span> = False

        <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span> <span class="HLcommands">is</span> <span class="HLspecial">True</span>: <span class="HLcomments"># From PCA to MSSA</span>
            nspace = [<span class="HLspecial">self</span>.npca,]*len(<span class="HLspecial">self</span>.pdata)
            <span class="HLcommands">if</span> <span class="HLspecial">self</span>.pc ==[]: <span class="HLcomments"># Still no PCA done</span>
                <span class="HLspecial">self</span>.<span class="HLpersonalised">pca</span>()
        <span class="HLcommands">else</span>:
            nspace = <span class="HLspecial">self</span>.ns

        <span class="HLcommands">if</span> nsvd <span class="HLcommands">is</span> not <span class="HLspecial">None</span>:
            <span class="HLspecial">self</span>.nsvd = nsvd


        <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span> <span class="HLcommands">is</span> <span class="HLspecial">True</span>: <span class="HLcomments"># Pre-PCA case</span>
            lneof, rneof, lnpc, rnpc, nev = spanlib_fort.<span class="HLpersonalised">svd</span>(Numeric.transpose(<span class="HLspecial">self</span>.pc[<span class="HLdigits">0</span>]), Numeric.transpose(<span class="HLspecial">self</span>.pc[<span class="HLdigits">1</span>]), <span class="HLspecial">self</span>.nsvd)
        <span class="HLcommands">else</span>: <span class="HLcomments"># Direct SVD case</span>
            lneof, rneof, lnpc, rnpc, nev = spanlib_fort.<span class="HLpersonalised">svd</span>(<span class="HLspecial">self</span>.pdata[<span class="HLdigits">0</span>], <span class="HLspecial">self</span>.pdata[<span class="HLdigits">1</span>], <span class="HLspecial">self</span>.nsvd)

        <span class="HLspecial">self</span>.svdeof = [lneof,rneof]
        <span class="HLspecial">self</span>.svdpc = [lnpc,rnpc]

        eof=[]
        pc=[]

        <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(<span class="HLdigits">2</span>):
            teof = MV.transpose(<span class="HLspecial">self</span>.svdeof[i])
            teof.<span class="HLfunctions">id</span>=<span class="HLstrings">'EOF'</span>
            teof.standard_name=<span class="HLstrings">'Empirical Orthogonal Function'</span>

            ax0=teof.getAxis(<span class="HLdigits">0</span>)
            ax0.<span class="HLfunctions">id</span>=<span class="HLstrings">'<span class="HLpersonalised">svd</span>'</span>
            ax0.standard_name=<span class="HLstrings">'<span class="HLpersonalised">SVD</span> Axis'</span>

            ax1=teof.getAxis(<span class="HLdigits">1</span>)
            ax1.<span class="HLfunctions">id</span>=<span class="HLstrings">'pc'</span>
            ax1.standard_name=<span class="HLstrings">'Principal Components Axis'</span>


            tpc=MV.transpose(MV.array(<span class="HLspecial">self</span>.svdpc[i]))
            tpc.<span class="HLfunctions">id</span>=<span class="HLstrings">'PC'</span>
            tpc.standard_name=<span class="HLstrings">'Principal Components'</span>
            tpc.setAxis(<span class="HLdigits">0</span>,ax0)
            
            ax3 = tpc.getAxis(<span class="HLdigits">1</span>)
            ax3.<span class="HLfunctions">id</span>=<span class="HLstrings">'time'</span>

            tev=MV.array(ntstev,<span class="HLfunctions">id</span>=<span class="HLstrings">'EV'</span>,axes=[ax0])
            tev.standard_name=<span class="HLstrings">'Eigen Values'</span>

            eof.append(teof)
            pc.append(tpc)

        <span class="HLcommands">return</span> eof[<span class="HLdigits">0</span>],pc[<span class="HLdigits">0</span>],eof[<span class="HLdigits">1</span>],pc[<span class="HLdigits">1</span>],ev


    <span class="HLcommands">def</span> <span class="HLpersonalised">reconstruct</span>(<span class="HLspecial">self</span>,start=<span class="HLdigits">1</span>,end=<span class="HLspecial">None</span>,<span class="HLpersonalised">mssa</span>=<span class="HLspecial">None</span>,<span class="HLpersonalised">pca</span>=<span class="HLspecial">None</span>,phases=False,nphases=<span class="HLdigits">8</span>,offset=.<span class="HLdigits">5</span>,firstphase=<span class="HLdigits">0</span>,<span class="HLpersonalised">svd</span>=<span class="HLspecial">None</span>):
        <span class="HLcomments">""" Reconstruct results from mssa or pca</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Description:::</span>
<span class="HLcomments">          This function performs recontructions to retreive the</span>
<span class="HLcomments">          the contribution of a selection of modes to the original field.</span>
<span class="HLcomments">          By default, it recontructs from available PCA and MSSA</span>
<span class="HLcomments">          results. Recontruction of MSSA modes also calls recontruction</span>
<span class="HLcomments">          from of pre-PCA to get back to the original space.</span>
<span class="HLcomments">          This function can optionally performs phase composites</span>
<span class="HLcomments">          (useful for pairs of MSSA modes = oscillations) on MSSA</span>
<span class="HLcomments">          recontructions.</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Usage:::</span>
<span class="HLcomments">        ffrec = reconstruct(start,end,mssa,pca)</span>
<span class="HLcomments"></span>
<span class="HLcomments">          start :: First mode</span>
<span class="HLcomments">          end   :: Last mode</span>
<span class="HLcomments">          mssa  :: Reconstruct MSSA if True</span>
<span class="HLcomments">          pca   :: Reconstruct PCA if True</span>
<span class="HLcomments">          phases :: Operate phase reconstruction True/False (default is False)</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments"></span>
<span class="HLcomments">        Output:::</span>
<span class="HLcomments">          ffrec :: Reconstructed field</span>
<span class="HLcomments">        :::</span>
<span class="HLcomments">        """</span>
        n1=start
        n2=end
        ntimes=<span class="HLspecial">self</span>.nt
        comments = <span class="HLstrings">'Reconstructed from'</span>
        axes=<span class="HLfunctions">list</span>(<span class="HLspecial">self</span>.axes)

        <span class="HLcommands">if</span> <span class="HLpersonalised">mssa</span> <span class="HLcommands">is</span> <span class="HLspecial">True</span> and <span class="HLspecial">self</span>.steof == []: <span class="HLcomments"># Want MSSA and didn't run it!</span>
            raise Exception, <span class="HLstrings">'Error you did not run <span class="HLpersonalised">MSSA</span> yet'</span>

        <span class="HLcommands">if</span> <span class="HLpersonalised">svd</span> <span class="HLcommands">is</span> <span class="HLspecial">True</span> and <span class="HLspecial">self</span>.svdeof == []:
            raise Exception, <span class="HLstrings">'Error you did not run <span class="HLpersonalised">SVD</span> yet'</span>
            
        <span class="HLcomments">## Check fr svd</span>
        <span class="HLcommands">if</span> <span class="HLpersonalised">svd</span> <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            <span class="HLcommands">if</span> <span class="HLspecial">self</span>.svdeof == []:
                <span class="HLpersonalised">svd</span> = False
            elif <span class="HLspecial">self</span>.steof==[]:
                <span class="HLpersonalised">svd</span> = <span class="HLspecial">True</span>
                
        <span class="HLcomments">## Check for default values for mssa and pca if not passed by user</span>
        <span class="HLcommands">if</span> <span class="HLpersonalised">mssa</span> <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            <span class="HLcommands">if</span> <span class="HLspecial">self</span>.steof ==[]:
                <span class="HLpersonalised">mssa</span> = False
            elif <span class="HLpersonalised">svd</span> <span class="HLcommands">is</span> False:
                <span class="HLpersonalised">mssa</span> = <span class="HLspecial">True</span>
            <span class="HLcommands">else</span>:
                <span class="HLpersonalised">mssa</span> = False

        <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span> <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
            <span class="HLcommands">if</span> <span class="HLspecial">self</span>.pc == []:
                <span class="HLpersonalised">pca</span> = False
            <span class="HLcommands">else</span>:
                <span class="HLpersonalised">pca</span> = <span class="HLspecial">True</span>


<span class="HLcomments">##         print 'mssa,pca,phases:',mssa,pca,phases</span>
        <span class="HLcommands">if</span> phases and not <span class="HLpersonalised">pca</span> and not <span class="HLpersonalised">mssa</span>:
            raise <span class="HLstrings">'Error you did not do any <span class="HLpersonalised">PCA</span> or <span class="HLpersonalised">MSSA</span>!\n To do a phases analysis only use the function %s <span class="HLcommands">in</span> this module.\n%s'</span> % (<span class="HLstrings">'<span class="HLpersonalised">computePhases</span>'</span>,<span class="HLpersonalised">computePhases</span>.__doc__)
        <span class="HLcomments">## Now do the actual reconstruct job</span>

        <span class="HLcommands">if</span> <span class="HLpersonalised">mssa</span>:
            comments+=<span class="HLstrings">' <span class="HLpersonalised">MSSA</span> '</span>
            <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span>:
                nspace=[<span class="HLspecial">self</span>.npca,]*len(<span class="HLspecial">self</span>.pdata[<span class="HLdigits">0</span>])
            <span class="HLcommands">else</span>:
                nspace=[]
                <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(len(<span class="HLspecial">self</span>.pdata)):
                    nspace.append(<span class="HLspecial">self</span>.pdata[i].shape[<span class="HLdigits">0</span>])

            <span class="HLcommands">if</span> n2 <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
                n2=<span class="HLspecial">self</span>.nmssa

            ffrec=[]
            <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(len(<span class="HLspecial">self</span>.pdata)):
                ffrec.append(spanlib_fort.mssa_rec(<span class="HLspecial">self</span>.steof[i], <span class="HLspecial">self</span>.stpc[i], nspace[i], <span class="HLspecial">self</span>.nt, <span class="HLspecial">self</span>.window, n1, n2))
<span class="HLcomments">##             print 'Ok did mssa',ffrec.shape</span>

        <span class="HLcommands">if</span> <span class="HLpersonalised">svd</span>:
            comments+=<span class="HLstrings">' <span class="HLpersonalised">SVD</span> '</span>
            <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span>:
                nspace=[<span class="HLspecial">self</span>.npca,<span class="HLspecial">self</span>.npca]
            <span class="HLcommands">else</span>:
                nspace=[]
                <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(<span class="HLdigits">2</span>):
                    nspace.append(<span class="HLspecial">self</span>.pdata[i].shape[<span class="HLdigits">0</span>])
                
            <span class="HLcommands">if</span> n2 <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
                n2=<span class="HLspecial">self</span>.nsvd

            ffrec=[]
            <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(<span class="HLdigits">2</span>):
                ffrec.append(spanlib_fort.pca_rec(<span class="HLspecial">self</span>.svdeof[i], <span class="HLspecial">self</span>.svdpc[i], nspace[i], <span class="HLspecial">self</span>.nt, n1, n2))

        <span class="HLcommands">if</span> phases:
            comments+=<span class="HLstrings">' Phases'</span>
            <span class="HLcommands">if</span> <span class="HLpersonalised">mssa</span>:
<span class="HLcomments">##                 print 'phase+mssa reconst'</span>
                
                <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(len(<span class="HLspecial">self</span>.pdata)):
                    ffrec[i] = <span class="HLpersonalised">computePhases</span>(ffrec[i],nphases,offset,firstphase)
            <span class="HLcommands">else</span>:
                ffrec=[]
                <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(len(<span class="HLspecial">self</span>.pdata)):
                    ffrec.append(<span class="HLpersonalised">computePhases</span>(Numeric.transpose(<span class="HLspecial">self</span>.pc[i]),nphases,offset,firstphase))

            <span class="HLcomments">## Replace time axis with phases axis</span>
            ntimes=nphases
            <span class="HLcommands">for</span> j <span class="HLcommands">in</span> range(len(<span class="HLspecial">self</span>.pdata)):
                <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(len(<span class="HLspecial">self</span>.axes[<span class="HLdigits">0</span>])):
                    <span class="HLcommands">if</span> axes[j][i].isTime():
                        axes[j][i]=ffrec[j].getAxis(<span class="HLdigits">1</span>)


        <span class="HLcommands">if</span> <span class="HLpersonalised">svd</span>:
            nloop=<span class="HLdigits">2</span>
        <span class="HLcommands">else</span>:
            nloop = len(<span class="HLspecial">self</span>.pdata)
            
        <span class="HLcommands">if</span> <span class="HLpersonalised">pca</span>:
            comments+=<span class="HLstrings">' <span class="HLpersonalised">PCA</span>'</span>
            <span class="HLcommands">if</span> <span class="HLpersonalised">mssa</span> <span class="HLcommands">is</span> <span class="HLspecial">True</span> or phases <span class="HLcommands">is</span> <span class="HLspecial">True</span> or <span class="HLpersonalised">svd</span> <span class="HLcommands">is</span> <span class="HLspecial">True</span>:
                pcreconstruct=[]
                <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(nloop):
                    pcreconstruct.append(Numeric.transpose(ffrec[i]))
                del(ffrec)
            <span class="HLcommands">else</span>:
                pcreconstruct = <span class="HLspecial">self</span>.pc

            <span class="HLcommands">if</span> <span class="HLpersonalised">mssa</span>:
               n1 = <span class="HLdigits">1</span>
               n2 = <span class="HLspecial">self</span>.npca
            elif n2 <span class="HLcommands">is</span> <span class="HLspecial">None</span>:
               n2 = <span class="HLspecial">self</span>.npca


<span class="HLcomments">##             print pcreconstruct.shape,self.ns,ntimes</span>
            ffrec=[]
            <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(nloop):
                ffrec.append(spanlib_fort.pca_rec(<span class="HLspecial">self</span>.eof[i], pcreconstruct[i], n1, n2))

<span class="HLcomments">##         print 'SEF.mask is:',self.mask</span>
                
        <span class="HLcommands">for</span> i <span class="HLcommands">in</span> range(nloop):
            <span class="HLcommands">if</span> <span class="HLspecial">self</span>.mask[i] <span class="HLcommands">is</span> not <span class="HLspecial">None</span>:
                ffrec[i] = MV.transpose(spanlib_fort.unpack3d(<span class="HLspecial">self</span>.mask[i],ffrec[i],<span class="HLdigits">1</span>.e20))
                ffrec[i] = MV.masked_where(Numeric.equal(Numeric.resize(Numeric.transpose(<span class="HLspecial">self</span>.mask[i]),ffrec[i].shape),<span class="HLdigits">0</span>),ffrec[i])
            <span class="HLcommands">else</span>:
                ffrec[i] = MV.transpose(ffrec[i])
            ffrec[i].setAxisList(axes[i])
            ffrec[i].<span class="HLfunctions">id</span>=<span class="HLspecial">self</span>.varname[i]
            ffrec[i].comment=comments
            <span class="HLcommands">if</span> not <span class="HLpersonalised">svd</span>:
                ffrec[i].setGrid(<span class="HLspecial">self</span>.grids[i])

        <span class="HLcommands">if</span> len(ffrec)==<span class="HLdigits">1</span>:
            <span class="HLcommands">return</span> ffrec[<span class="HLdigits">0</span>]
        <span class="HLcommands">else</span>:
            <span class="HLcommands">return</span> ffrec

    <span class="HLcommands">def</span> clean(<span class="HLspecial">self</span>):
        <span class="HLspecial">self</span>.pc=[]
        <span class="HLspecial">self</span>.eof=[]
        <span class="HLspecial">self</span>.stpc=[]
        <span class="HLspecial">self</span>.steof=[]
        <span class="HLspecial">self</span>.svdpc=[]
        <span class="HLspecial">self</span>.svdeof=[]







</pre></div></body></html>
