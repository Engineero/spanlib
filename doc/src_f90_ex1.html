<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SpanLib - Fortran 90 example 1</title><link rel="stylesheet" href="spanlib.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.69.1" /></head><body><div class="article" lang="en" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="id2634124"></a>SpanLib - Fortran 90 example 1</h1></div></div><hr /></div><pre class="programlisting"><span class="HLcomments">! File: example1.f90</span>
<span class="HLcomments">!</span>
<span class="HLcomments">! This file is part of the SpanLib library.</span>
<span class="HLcomments">! Copyright (C) 2006  Stephane Raynaud</span>
<span class="HLcomments">! Contact: stephane dot raynaud at gmail dot com</span>
<span class="HLcomments">!</span>
<span class="HLcomments">! This library is free software; you can redistribute it and/or</span>
<span class="HLcomments">! modify it under the terms of the GNU Lesser General Public</span>
<span class="HLcomments">! License as published by the Free Software Foundation; either</span>
<span class="HLcomments">! version 2.1 of the License, or (at your option) any later version.</span>
<span class="HLcomments">!</span>
<span class="HLcomments">! This library is distributed in the hope that it will be useful,</span>
<span class="HLcomments">! but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="HLcomments">! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="HLcomments">! Lesser General Public License for more details.</span>
<span class="HLcomments">!</span>
<span class="HLcomments">! You should have received a copy of the GNU Lesser General Public</span>
<span class="HLcomments">! License along with this library; if not, write to the Free Software</span>
<span class="HLcomments">! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</span>

<span class="HLroutines">program</span> example

	<span class="HLcomments">! This simple example shows how to PCA and MSSA subroutines from this package.</span>
	<span class="HLcomments">! Warning: it requires netcdf for in/outputs.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! We start from longitude/latitude/time value of Pacific Sea Surface Temperature</span>
	<span class="HLcomments">! that include the El Nino Southern Oscillation signal.</span>
	<span class="HLcomments">! Input is the netcdf file data2.cdf.</span>
	<span class="HLcomments">! We remove land points from the initial array according</span>
	<span class="HLcomments">! to the netcdf missing_value attribute of the analysed variable (data are "packed").</span>
	<span class="HLcomments">! A PCA is used to reduce the degrees of freedoom before MSSA analysis.</span>
	<span class="HLcomments">! Weights for PCA are computed as a fonction of latitude.</span>
	<span class="HLcomments">! Then, we assume that we have already identified an oscillation (after tests).</span>
	<span class="HLcomments">! This oscillation, given by a pair of MSSA modes, is then</span>
	<span class="HLcomments">! reconstructed from the MSSA and PCA spaces.</span>
	<span class="HLcomments">! Finally, phase composites are computed from this reconstructed oscillation.</span>
	<span class="HLcomments">! The oscillation is outputed in a netcdf file (pair_1.cdf).</span>
	<span class="HLcomments">! MSSA eigenvalue are stored in the output netcdf file. This shows</span>
	<span class="HLcomments">! you pairs due to oscillatory modes.</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Initial data set (data2.cdf):</span>
	<span class="HLcomments">! - origin: updated Reynolds and Smith (1996) SST (netcdf file)</span>
	<span class="HLcomments">! - origin url: data selector from http://iridl.ldeo.columbia.edu</span>
	<span class="HLcomments">! - how to get it [10Mb]: http://stefdeperou.free.fr/pub/data.cdf</span>
	<span class="HLcomments">! - area of study: tropical pacific [130.5E:75.5W, 29.5S:29.5N] (155x60 grid points)</span>
	<span class="HLcomments">! - period of study: Jan1982:Dec2005 (288 time steps)</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Parameters:</span>
	<span class="HLcomments">! - Only the first 20 PCs are retainedand given to the MSSA</span>
	<span class="HLcomments">! - A window of 7 years (84 months) is chosen for the MSSA</span>
	<span class="HLcomments">! - Phase composites use 8 phases</span>
	<span class="HLcomments">! - An offset of 0.4 and is used for composites</span>
	<span class="HLcomments">! - The first phase of composites is set at 180 degrees (minimal value)</span>
	<span class="HLcomments">!</span>
	<span class="HLcomments">! Note:</span>
	<span class="HLcomments">!	This example should run only a few seconds.</span>
	<span class="HLcomments">!	If it is not the case, your BLAS/LAPACK librairy is not optimized.</span>

	<span class="HLroutines">use</span> spanlib
	<span class="HLroutines">use</span> netcdf

	<span class="HLroutines">implicit</span> <span class="HLattributes">none</span>

	<span class="HLcomments">! Parameters</span>
	<span class="HLcomments">! ----------</span>
	<span class="HLroutines">integer</span>,<span class="HLattributes">parameter</span> :: nkeep_pca=<span class="HLdigits">10</span>, nkeep_mssa=<span class="HLdigits">6</span>, nwindow=<span class="HLdigits">84</span>, &amp;
		&amp; first_mode=<span class="HLdigits">1</span>, nphases=<span class="HLdigits">8</span>
	<span class="HLroutines">real</span>(wp), <span class="HLattributes">parameter</span> :: offset=<span class="HLdigits">0</span>.d0, first_phase=<span class="HLdigits">180</span>.d0, &amp;
		&amp; new_missing_value=-<span class="HLdigits">999</span>.d0
	<span class="HLroutines">character</span>(len=<span class="HLdigits">20</span>), <span class="HLattributes">parameter</span> :: input_nc_file=<span class="HLstrings">"data2.cdf"</span>, &amp;
		&amp; output_nc_file=<span class="HLstrings">"output_fortran1.nc"</span>, var_name=<span class="HLstrings">'ssta'</span>

	<span class="HLcomments">! Other declarations</span>
	<span class="HLcomments">! ------------------</span>
	<span class="HLroutines">real</span>(wp), <span class="HLattributes">allocatable</span> :: field(:,:,:), weights(:,:), &amp;
		&amp; lat(:), lon(:), time(:)
	<span class="HLroutines">real</span>(wp), <span class="HLattributes">allocatable</span> :: reco(:,:,:), phasecomps(:,:,:)
	<span class="HLroutines">logical</span>, <span class="HLattributes">allocatable</span> :: mask(:,:)
	<span class="HLroutines">real</span>(wp), <span class="HLattributes">allocatable</span> :: packed_field(:,:), &amp;
		&amp; packed_weights(:), packed_phasecomps(:,:), stphasecomps(:,:)
	<span class="HLroutines">real</span>(wp), <span class="HLattributes">allocatable</span> :: eof(:,:), pc(:,:), &amp;
		&amp; stpair(:,:), pair(:,:)
	<span class="HLroutines">real</span>(wp), <span class="HLattributes">allocatable</span> :: steof(:,:),stpc(:,:),stev(:)
	<span class="HLroutines">character</span>(len=<span class="HLdigits">20</span>) :: lon_units, lat_units, var_units, &amp;
		&amp;	lon_name, lat_name, time_name, time_units
	<span class="HLroutines">integer</span> :: ncid, dimids(<span class="HLdigits">5</span>), varid, lonid, latid, phaseid, &amp;
		&amp; timeid, phcoid, recoid, origid, modeid, evid
	<span class="HLroutines">integer</span>(kind=<span class="HLdigits">4</span>) :: i, nspace, nlon, nlat, ntime
	<span class="HLroutines">real</span>(wp) :: pi, missing_value

	<span class="HLcomments">! Precision</span>
	<span class="HLcomments">! ---------</span>
	<span class="HLroutines">if</span>(wp==<span class="HLdigits">8</span>)<span class="HLroutines">then</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'Using double precision'</span>
	<span class="HLroutines">else</span>
		<span class="HLroutines">print</span>*,<span class="HLstrings">'Using simple precision'</span>
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

	<span class="HLcomments">! Get the initial sst field from the netcdf file</span>
	<span class="HLcomments">! ----------------------------------------------</span>
	<span class="HLroutines">print</span>*,<span class="HLstrings">'Reading inputs...'</span>
	<span class="HLroutines">call</span> err(nf90_open(input_nc_file, nf90_nowrite, ncid))
	<span class="HLroutines">call</span> err(nf90_inq_varid(ncid, var_name, varid))
	<span class="HLroutines">call</span> err(nf90_inquire_variable(ncid, varid, dimids=dimids(<span class="HLdigits">1</span>:<span class="HLdigits">3</span>)))
	<span class="HLroutines">call</span> err(nf90_inquire_dimension(ncid, dimids(<span class="HLdigits">1</span>), &amp;
		&amp;	name=lon_name, len=nlon))
	<span class="HLroutines">call</span> err(nf90_inquire_dimension(ncid, dimids(<span class="HLdigits">2</span>), &amp;
		&amp;	name=lat_name, len=nlat))
	<span class="HLroutines">call</span> err(nf90_inquire_dimension(ncid, dimids(<span class="HLdigits">3</span>), &amp;
		&amp;	name=time_name, len=ntime))
	<span class="HLfunctions">allocate</span>(field(nlon,nlat,ntime))
	<span class="HLfunctions">allocate</span>(mask(nlon,nlat))
	<span class="HLfunctions">allocate</span>(weights(nlon,nlat))
	<span class="HLfunctions">allocate</span>(lon(nlon))
	<span class="HLfunctions">allocate</span>(lat(nlat))
	<span class="HLfunctions">allocate</span>(time(ntime))
	<span class="HLroutines">call</span> err(nf90_get_var(ncid, varid, field))
	<span class="HLroutines">call</span> err(nf90_get_att(ncid, varid, <span class="HLstrings">'missing_value'</span>, &amp;
		&amp; missing_value))
	<span class="HLroutines">call</span> err(nf90_get_att(ncid, varid, <span class="HLstrings">'units'</span>, var_units))
	<span class="HLroutines">call</span> err(nf90_inq_varid(ncid, lon_name, varid))
	<span class="HLroutines">call</span> err(nf90_get_var(ncid, varid, lon))
	<span class="HLroutines">call</span> err(nf90_get_att(ncid, varid, <span class="HLstrings">'units'</span>, lon_units))
	<span class="HLroutines">call</span> err(nf90_inq_varid(ncid, lat_name, varid))
	<span class="HLroutines">call</span> err(nf90_get_var(ncid, varid, lat))
	<span class="HLroutines">call</span> err(nf90_get_att(ncid, varid, <span class="HLstrings">'units'</span>, lat_units))
	<span class="HLroutines">call</span> err(nf90_inq_varid(ncid, time_name, varid))
	<span class="HLroutines">call</span> err(nf90_get_var(ncid, varid, time))
	<span class="HLroutines">call</span> err(nf90_get_att(ncid, varid, <span class="HLstrings">'units'</span>, time_units))
	<span class="HLroutines">call</span> err(nf90_close(ncid))


	<span class="HLcomments">! Format (pack) data to have only one space dimension</span>
	<span class="HLcomments">! ---------------------------------------------------</span>
	<span class="HLroutines">print</span>*,<span class="HLstrings">'Packing...'</span>

	<span class="HLcomments">! Compute weights proportional to grid point area</span>
	pi = cos(-<span class="HLdigits">1</span>.)
	<span class="HLroutines">do</span> i=<span class="HLdigits">1</span>,nlat
		weights(:,i) = cos(lat(i)*pi/<span class="HLdigits">180</span>.)
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLcomments">! Now pack</span>
	mask = (field(:,:,<span class="HLdigits">1</span>) /= missing_value)
	<span class="HLfunctions">allocate</span>(packed_field(count(mask), ntime))
	<span class="HLroutines">do</span> i=<span class="HLdigits">1</span>, ntime
		packed_field(:,i) = <span class="HLfunctions">pack</span>(field(:,:,i), mask)
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>
	nspace = count(mask)
	<span class="HLfunctions">allocate</span>(packed_weights(nspace))
	packed_weights = <span class="HLfunctions">pack</span>(weights, mask)


	<span class="HLcomments">! Perform a PCA to reduce the d.o.f</span>
	<span class="HLcomments">! ---------------------------------</span>
	<span class="HLroutines">print</span>*,<span class="HLstrings">'[<span class="HLpersonalised">sl_pca</span>] Pre-PCA...'</span>
	<span class="HLfunctions">allocate</span>(eof(nspace, nkeep_pca))
	<span class="HLfunctions">allocate</span>(pc(ntime,   nkeep_pca))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca</span>(packed_field, nkeep_pca, xeof=eof, &amp;
		&amp;	pc=pc, weights=packed_weights)
	<span class="HLfunctions">deallocate</span>(packed_field)

	<span class="HLcomments">! We send results from PCA to MSSA</span>
	<span class="HLcomments">! --------------------------------</span>
	<span class="HLroutines">print</span>*,<span class="HLstrings">'[<span class="HLpersonalised">sl_mssa</span>] MSSA...'</span>
	<span class="HLfunctions">allocate</span>(steof(nkeep_pca*nwindow, nkeep_mssa))
	<span class="HLfunctions">allocate</span>(stpc(ntime-nwindow+<span class="HLdigits">1</span>,    nkeep_mssa))
	<span class="HLfunctions">allocate</span>(stev(                    nkeep_mssa))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_mssa</span>(<span class="HLfunctions">transpose</span>(pc), nwindow, nkeep_mssa, &amp;
		&amp;	steof=steof, stpc=stpc, ev=stev)

	<span class="HLcomments">! We reconstruct modes [first_mode + first_mode+1] of MSSA</span>
	<span class="HLcomments">! --------------------------------------------------------</span>
	<span class="HLroutines">print</span>*,<span class="HLstrings">'[<span class="HLpersonalised">sl_mssa_rec</span>] MSSA reconstruction...'</span>
	<span class="HLfunctions">allocate</span>(stpair(nkeep_pca, ntime))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_mssa_rec</span>(steof(:,first_mode:first_mode+<span class="HLdigits">1</span>), &amp;
		&amp; stpc(:,first_mode:first_mode+<span class="HLdigits">1</span>), nwindow, stpair)
	<span class="HLfunctions">deallocate</span>(steof, stpc)

	<span class="HLcomments">! We compute phases composites for the reconstructed oscillation</span>
	<span class="HLcomments">! ---------------------------------------------------------------</span>
	<span class="HLroutines">print</span>*,<span class="HLstrings">'[<span class="HLpersonalised">sl_phasecomp</span>] Phase composites...'</span>
	<span class="HLfunctions">allocate</span>(stphasecomps(nkeep_pca, nphases))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_phasecomp</span>(stpair, nphases, stphasecomps, &amp;
		&amp;	offset=offset, firstphase=first_phase)

	<span class="HLcomments">! We go back to the physical space for</span>
	<span class="HLcomments">! the full oscillation AND its composites</span>
	<span class="HLcomments">! ---------------------------------------</span>
	<span class="HLroutines">print</span>*,<span class="HLstrings">'[<span class="HLpersonalised">sl_pca_rec</span>] Back to the physical space...'</span>
	<span class="HLfunctions">allocate</span>(pair(nspace, ntime))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca_rec</span>(eof, <span class="HLfunctions">transpose</span>(stpair), pair)
	<span class="HLfunctions">allocate</span>(packed_phasecomps(nspace, nphases))
	<span class="HLroutines">call</span> <span class="HLpersonalised">sl_pca_rec</span>(eof, <span class="HLfunctions">transpose</span>(stphasecomps), packed_phasecomps)
	<span class="HLfunctions">deallocate</span>(stpair, eof, stphasecomps)

	<span class="HLcomments">! Unpacking</span>
	<span class="HLcomments">! ---------</span>
	<span class="HLroutines">print</span>*,<span class="HLstrings">'Unpacking...'</span>
	<span class="HLfunctions">allocate</span>(reco(nlon,nlat,ntime))
	<span class="HLroutines">do</span> i=<span class="HLdigits">1</span>, ntime
		reco(:,:,i) = <span class="HLfunctions">unpack</span>(pair(:,i), mask, new_missing_value)
		where(.<span class="HLfunctions">not</span>.mask)field(:,:,i) = new_missing_value
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>
	<span class="HLfunctions">allocate</span>(phasecomps(nlon,nlat,nphases))
	<span class="HLroutines">do</span> i=<span class="HLdigits">1</span>, nphases
		phasecomps(:,:,i) = <span class="HLfunctions">unpack</span>(packed_phasecomps(:,i), mask, &amp;
		 &amp; new_missing_value)
	<span class="HLroutines">end</span> <span class="HLroutines">do</span>

	<span class="HLcomments">! Write out the phase composites of the first oscillation</span>
	<span class="HLcomments">! -------------------------------------------------------</span>
	<span class="HLroutines">print</span>*,<span class="HLstrings">'Writing out...'</span>
	<span class="HLcomments">! File</span>
	<span class="HLroutines">call</span> err(nf90_create(output_nc_file, nf90_write, ncid))
	<span class="HLcomments">! Dimensions</span>
	<span class="HLroutines">call</span> err(nf90_def_dim(ncid, <span class="HLstrings">'lon'</span>, nlon, dimids(<span class="HLdigits">1</span>)))
	<span class="HLroutines">call</span> err(nf90_def_dim(ncid, <span class="HLstrings">'lat'</span>, nlat, dimids(<span class="HLdigits">2</span>)))
	<span class="HLroutines">call</span> err(nf90_def_dim(ncid, <span class="HLstrings">'time'</span>, ntime, dimids(<span class="HLdigits">3</span>)))
	<span class="HLroutines">call</span> err(nf90_def_dim(ncid, <span class="HLstrings">'phase'</span>, nphases, dimids(<span class="HLdigits">4</span>)))
	<span class="HLroutines">call</span> err(nf90_def_dim(ncid, <span class="HLstrings">'mode'</span>, nkeep_mssa, dimids(<span class="HLdigits">5</span>)))
	<span class="HLcomments">! Variables</span>
	<span class="HLroutines">call</span> err(nf90_def_var(ncid, <span class="HLstrings">'lon'</span>, nf90_float, dimids(<span class="HLdigits">1</span>), lonid))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, lonid, <span class="HLstrings">'long_name'</span>, <span class="HLstrings">'Longitude'</span>))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, lonid, <span class="HLstrings">'units'</span>, lon_units))
	<span class="HLroutines">call</span> err(nf90_def_var(ncid, <span class="HLstrings">'lat'</span>, nf90_float, dimids(<span class="HLdigits">2</span>), latid))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, latid, <span class="HLstrings">'long_name'</span>, <span class="HLstrings">'Latitude'</span>))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, latid, <span class="HLstrings">'units'</span>, lat_units))
	<span class="HLroutines">call</span> err(nf90_def_var(ncid, <span class="HLstrings">'time'</span>, nf90_float, dimids(<span class="HLdigits">3</span>), &amp;
		&amp; timeid))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, timeid, <span class="HLstrings">'long_name'</span>, <span class="HLstrings">'Time'</span>))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, timeid, <span class="HLstrings">'units'</span>, time_units))
	<span class="HLroutines">call</span> err(nf90_def_var(ncid, <span class="HLstrings">'phase'</span>, nf90_float, dimids(<span class="HLdigits">4</span>), &amp;
		&amp; phaseid))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, phaseid, <span class="HLstrings">'long_name'</span>, <span class="HLstrings">'Phase'</span>))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, phaseid, <span class="HLstrings">'units'</span>, <span class="HLstrings">'level'</span>))
	<span class="HLroutines">call</span> err(nf90_def_var(ncid, <span class="HLstrings">'mode'</span>, nf90_float, dimids(<span class="HLdigits">5</span>), &amp;
		&amp; modeid))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, modeid, <span class="HLstrings">'long_name'</span>, <span class="HLstrings">'Mode'</span>))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, modeid, <span class="HLstrings">'units'</span>, <span class="HLstrings">'level'</span>))
	<span class="HLroutines">call</span> err(nf90_def_var(ncid, <span class="HLstrings">'orig'</span>, nf90_float, dimids(<span class="HLdigits">1</span>:<span class="HLdigits">3</span>), &amp;
	 &amp; origid))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, origid, <span class="HLstrings">'long_name'</span>, &amp;
		&amp; <span class="HLstrings">'SST anomaly / original field'</span>))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, origid, <span class="HLstrings">'units'</span>, var_units))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, origid, <span class="HLstrings">'missing_value'</span>, &amp;
		&amp; new_missing_value))
	<span class="HLroutines">call</span> err(nf90_def_var(ncid, <span class="HLstrings">'reco1'</span>, nf90_float, dimids(<span class="HLdigits">1</span>:<span class="HLdigits">3</span>), &amp;
		&amp; recoid))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, recoid, <span class="HLstrings">'long_name'</span>, &amp;
		&amp; <span class="HLstrings">'SST anomaly / reconstruction of first pair'</span>))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, recoid, <span class="HLstrings">'units'</span>, var_units))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, recoid, <span class="HLstrings">'missing_value'</span>, &amp;
		&amp; new_missing_value))
	<span class="HLroutines">call</span> err(nf90_def_var(ncid, <span class="HLstrings">'pair1'</span>, nf90_float, &amp;
		&amp; (/dimids(<span class="HLdigits">1</span>),dimids(<span class="HLdigits">2</span>),dimids(<span class="HLdigits">4</span>)/), phcoid))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, phcoid, <span class="HLstrings">'long_name'</span>, &amp;
		&amp;<span class="HLstrings">'SST anomaly / phase composite of first pair'</span>))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, phcoid, <span class="HLstrings">'units'</span>, var_units))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, phcoid, <span class="HLstrings">'missing_value'</span>, &amp;
		&amp; new_missing_value))
	<span class="HLroutines">call</span> err(nf90_def_var(ncid, <span class="HLstrings">'ev'</span>, nf90_float, dimids(<span class="HLdigits">5</span>), evid))
	<span class="HLroutines">call</span> err(nf90_put_att(ncid, evid, <span class="HLstrings">'long_name'</span>, &amp;
		&amp;<span class="HLstrings">'MSSA eigen values'</span>))
	<span class="HLcomments">! Values</span>
	<span class="HLroutines">call</span> err(nf90_enddef(ncid))
	<span class="HLroutines">call</span> err(nf90_put_var(ncid, lonid, lon))
	<span class="HLroutines">call</span> err(nf90_put_var(ncid, latid, lat))
	<span class="HLroutines">call</span> err(nf90_put_var(ncid, timeid, time))
	<span class="HLroutines">call</span> err(nf90_put_var(ncid, phaseid, float((/(i,i=<span class="HLdigits">1</span>,nphases)/))))
	<span class="HLroutines">call</span> err(nf90_put_var(ncid, modeid, &amp;
		&amp; float((/(i,i=<span class="HLdigits">1</span>,nkeep_mssa)/))))
	<span class="HLroutines">call</span> err(nf90_put_var(ncid, origid, field))
	<span class="HLroutines">call</span> err(nf90_put_var(ncid, recoid, reco))
	<span class="HLroutines">call</span> err(nf90_put_var(ncid, phcoid, phasecomps))
	<span class="HLroutines">call</span> err(nf90_put_var(ncid, evid, stev))
	<span class="HLroutines">call</span> err(nf90_close(ncid))

<span class="HLroutines">end</span> <span class="HLroutines">program</span> example

<span class="HLroutines">subroutine</span> err(jstatus)

	<span class="HLroutines">use</span> netcdf

	<span class="HLroutines">integer</span> :: jstatus

	<span class="HLroutines">if</span> (jstatus .ne. nf90_noerr) <span class="HLroutines">then</span>
		<span class="HLroutines">print</span> *, <span class="HLfunctions">trim</span>(nf90_strerror(jstatus))
		stop
	<span class="HLroutines">end</span> <span class="HLroutines">if</span>

<span class="HLroutines">end</span> <span class="HLroutines">subroutine</span> err

</pre></div></body></html>
